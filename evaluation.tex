\section{Evaluation}
\label{SEC:evaluation}

Here we go.  This is the part where we write about our evaluation.  We've
built this great tool and we want to show you how it lives up to the
expectations that we've set for it.  To do this we've set up a series of
tests that exercise different capabilities and talk about how the tool did.

Here's some questions designed to give you an idea of what we're testing:


\begin{itemize}

  \item{Are we able to express the same sorts of things that the earlier
    crashsim work did?}

  \item{Ok so system calls are cool but can we work with other formats?
    How quickly can we support new formats?}

  \item{Great! Anomalies are pretty neat but what else can you do with the
    tool? (network/firewall stuff)}

  \item{Ok you can do all kinds of things but how fast can you do them?}

\end{itemize}


\subsection{Can we do the same sorts of things crashsim could do?}

Given that this work was motivated
in large part
by the success of the SEA technique,
we wanted to ensure that
the language we've developed
was sufficiently powerful
to describe the anomalies that they were able to find bugs with.
Specifically, we decided to take a look at their Unusual Filetype mutator,
and Cross-disk file move checkers which were responsible for the bulk of
the bugs that they found.

\begin{figure}[H]
\centering
\begin{tabular}{c}
\begin{lstlisting}
\\ This is absolutely a fake listing that will be changed out for a real
\\ one!!  Preston -> Don't forget to do this!
#include "stdio.h"

int main() {
    printf("Hello world!\n");
    return 0;
};
\end{lstlisting}
\end{tabular}
\caption{Unusual filetype mutator in CSlang}
\label{lst:UnusualFiletypeCSlang}
\end{figure}

So without further ado, check out this cool CSlang listing that implements
the unusual filetype mutator in figure~\ref{lst:UnusualFiletypeCSlang}
As you can see its nice and short and you can tell what's happening!
We're matching on one of stat, fstat, or lstat and changing the ST\_MODE
parameter inside the returned data structure.
CSlang makes this easy to do for three reasons:
\begin{enumerate}
  \item{You don't have to manually write your automaton matching code}
  \item{You only have to write rules for system calls you're interested in}
  \item{You can elide all the parts of the system call you don't care
    about}
\end{enumerate}

Compare this to Python code that tries to do the same thing!

\begin{figure}[H]
\centering
\begin{tabular}{c}
\begin{lstlisting}
\\ This is absolutely a fake listing that will be changed out for a real
\\ one!!  Preston -> Don't forget to do this!
#include "stdio.h"

int main() {
    printf("Hello world!\n");
    return 0;
};
\end{lstlisting}
\end{tabular}
\caption{Python code that implements the unusual filetype mutator}
\label{lst:UnusualFiletypePython}
\end{figure}

See how long that is?  And this is just a small piece!  CSlang takes care
of the annoying boilerplate and lets you get done what you need to get
done.

We also took a look at the Cross-Disk move checkers.
This one also found a lot of bugs for the CrashSim folks.
In this case, we implemented several CSlang programs that each performed
one of the checks the other paper was interested in.
These programs didn't perform any mutation but if they accept a particular
execution then that execution performed the check they were looking for.
If all the programs pass for a given execution then we can pretty confident
that the application did everything it needed to in order to move a file
from one disk to another correctly.

\begin{figure}[H]
\centering
\begin{tabular}{c}
\begin{lstlisting}
\\ This is absolutely a fake listing that will be changed out for a real
\\ one!!  Preston -> Don't forget to do this!
#include "stdio.h"

int main() {
    printf("Hello world!\n");
    return 0;
};
\end{lstlisting}
\end{tabular}
\caption{One of the cross disk move checkers implemented in CSlang}
\label{lst:Cross-Disk Move}
\end{figure}

We were not able to do the check for extended file attributes because we
don't have the capability to store an arbitrary list of values.  This is a
feature we are planning to add in the near future.

\begin{figure}[H]
\centering
\begin{tabular}{c}
\begin{lstlisting}
\\ This is absolutely a fake listing that will be changed out for a real
\\ one!!  Preston -> Don't forget to do this!
#include "stdio.h"

int main() {
    printf("Hello world!\n");
    return 0;
};
\end{lstlisting}
\end{tabular}
\caption{One of the cross disk move checkers implemented in Python}
\label{lst:Cross-Disk Move}
\end{figure}

As you can see things are much shorter and easier to read.  This is largely
because CSlang is a domain specific language rather than a general purpose
one.  This is a big reason we decided to make it.


\subsection{Working with other formats}

Early on we realized that CSlang could be used to consume and process
formats other than system calls.  Throughout its development process
we maintained this flexibility.  To make sure everything went according to
plan we add support for a format that was similar enough to system calls
that we were confident that it would work but different enough to show off
the language's flexibility.

In the end we settled on JSONRPC...


Given how well this went, we decided to expand our reach to another similar
format -- XMLRPC.  To get a more accurate idea of how difficult this was we
recorded out time to plan and implement the module.  We found that it took
around 2 hours
%2:09:14 to be specific%
worth of planning.  Most of this time was evaluating our options for
Python XML parsing modules.
Creating our initial implementation took around an hour
%1:14:32

With these formats we did many things...


To further ease the processing of new formats we added a generic CSV
processor.  This processor consumes a CSV row by row and allows operations
to be performed on each field.  The purpose of this capability is to allow
users to quickly get useful work done at the expense of some rigor/type
checking etc.


\subsection{Function like stuff is great but can we do other things?}

After our success in the above work we wanted to stretch CSlang to perform
useful work in a significantly different domain.  We showed that CSlang
could process common protocols used to communicate across networks but
could we do something interesting with the network traffic itself.

Using generic CSV support we processed incoming network traffic as recorded
by sysdig.  We constructed CSlang programs that could take incoming network
traffic, recognize a pattern and output a firewall rule to address it.

At a high level this works as follows:
Sysdig records network traffic, extracts the fields we are interested in,
and outputs them as a CSV.  We use our generic CSV processor to read this
representation of the network traffic and process it with a transducer.
The transducer outputs new stream of CSV data that is handed to a shell
script that transforms them into IPtables rules.

While we were happy with the results of this effort there were some
drawbacks.  Primarily, we do not try to generate an optimal set of rules
for a given stream of input network traffic.  In many cases there are
duplicate or unnecessary rules that would be undesirable in a final rule
set.  Fortunately, other work as been done in the area of optimizing
firewall rules so we are confident a post-processing pass could be put in
place to mitigate this problem.


\subsection{The question of performance}

It doesn't matter how useful a tool is if it takes too long to get its work
done.  As a result, performance is a concern.  Though our implementation is
only a prototype, we wanted to make sure that it wasn't overly slow in
getting its work done.  To make this determination we devised a series of
performance tests.  The results of these tests can be seen in
table~\ref{tbl:perf}.

\begin{figure}
  \begin{tabular}{|c|c|c|}
  Test & Input Size on Disk & Num. Elem. \\
  test1        & 1GB                        & 10000 \\
  test2        & 2GB                        & 20000 \\
  test3        & 3GB                        & 30000 \\
\end{tabular}
\label{tbl:perf}
\caption{performance results table}
\end{figure}

