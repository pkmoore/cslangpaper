\section{Evaluation}
\label{SEC:evaluation}

With our prototype in hand we organized a set of
evaluations that would let us know if the CSlang would be as effective
in real world situations.
We designed our tests to answer the following questions:

\begin{itemize}

  \item{Can CSlang express the sorts of anomalies used by SEA to identify
    bugs?}

  \item{How easy is it to extend CSlang to support input formats other than
    system calls?}

  \item{Can CSlang process input streams in a reasonable amount of time?}

\end{itemize}


\subsection{Expressing SEA Anomalies}
\label{sub:SEAAnomalies}
Given that this work was motivated
in large part
by the effectiveness of the SEA technique,
our first test of CSlang was using it to reproduce the anomalies described
in the original paper.
We wanted to ensure that
the language we developed
would be sufficiently powerful
to describe the anomalies the
SEA research team used to
find bugs.
Specifically,
we set out to test CSlang's ability to recreate
the study's Unusual Filetype mutator,
and its Cross-disk file move checkers, which were used to identify
the bulk of
the bugs that were found.
Our hope was that by using CSlang we could eliminate boiler plate code,
save effort by handling common tasks automatically, and improve reliability
by providing a structured way to modify and output system call sequences.

\begin{figure}[H]
\centering
\begin{tabular}{c}
\begin{lstlisting}
\\ This is absolutely a fake listing that will be changed out for a real
\\ one!!  Preston -> Don't forget to do this!
#include "stdio.h"

int main() {
    printf("Hello world!\n");
    return 0;
};
\end{lstlisting}
\end{tabular}
\caption{Unusual filetype mutator in CSlang}
\label{lst:UnusualFiletypeCSlang}
\end{figure}

\subsubsection{Creating the Unusual Filetype Mutator}
\label{subsub:UnusualFiletype}
For the first phase of this work,
we used CSlang to implement an ``Unusual Filetype''
mutator.
This mutator, presented in
Figure~\ref{lst:UnusualFiletypeCSlang},
should take an input trace
that contains a call to either {\tt stat()},
{\tt fstat()},
or {\tt lstat()}
and modify the call's result data structure such
that its {\tt ST\_MODE} member will contain one of the values from
Table~\ref{tbl:ST_MODEValues}.  As can be seen in
Figure~\ref{lst:UnusualFiletypeCSlang}, CSlang's semantics mean such an
operation can be captured with only a handful of lines of code.  In the
figure
lines XX-XX define what {\tt stat()}, {\tt fstat()}, and {\tt
lstat()} calls look like and which parameter contains the result buffer.
Line YY generates an accepting state that, when entered, produces an output
system call with a modified value in the return structure's {\tt st\_mode}
field.  Such output can then be used to modify the results of a running
application's system calls in order to carry out the remaining steps of the
SEA technique.

\begin{figure}
  \begin{tabular}{|c|c}
  Value    & Meaning          \\
  IF\_BLK  & Block Device     \\
  IF\_CHR  & Character Device \\
  IF\_SOCK & Socket           \\
\end{tabular}
\caption{ST\_MODE values}
\label{tbl:ST_MODEValues}
\end{figure}

CSlang's advantages are made even more obvious when the CSlang Unusual
Filetype mutator is compared to a program that implements the same
functionality in a general purpose programming language like Python.
Figure~\ref{lst:UnusualFiletypePython} shows an excerpt from a XX line
Python program taken from the SEA paper's CrashSimulator that performs the
above operation.  Comparing this listing to
Figure~\ref{lst:UnusualFiletypeCSlang} shows several key differences:

\textit{Minimal boilerplate code:} The CSlang program lacks the boilerplate
code associated with
reading an input trace, managing mutator state, and producing output.
This is possible because CSlang's capabilities are narrowly defined to
only describe the states and operations of a mutator.  This means these
functions can be generically implemented within CSlang's core eliminating
the need for users to do so manually.

\textit{No code required to filter out uninteresting calls:}
CSlang's user does
not need to write any code to exclude system
calls outside of the desired set.  Each statement defines a new state with
incoming and outgoing transitions configured such that any system calls not
dealt with in the CSlang program are ignored.

\textit{Easy to modify call contents:}  CSlang's operators make it
trivial to change components of a system call
and produce output without having to regenerate the remainder of its
parameters.
This is a far cry
from the Python program which relies on manual, fragile string manipulation
to achieve the same effect.


\begin{figure}[H]
\centering
\begin{tabular}{c}
\begin{lstlisting}
\\ This is absolutely a fake listing that will be changed out for a real
\\ one!!  Preston -> Don't forget to do this!
#include "stdio.h"

int main() {
    printf("Hello world!\n");
    return 0;
};
\end{lstlisting}
\end{tabular}
\caption{Python code that implements the unusual filetype mutator}
\label{lst:UnusualFiletypePython}
\end{figure}

\subsubsection{Creating the Cross-Disk Move Checkers}

The second phase of this work involved the recreation of a set of
``checkers'' that could examine an application as it moved a file from one
disk to another and report whether or not the operation was carried
out correctly.  These checkers took advantage of the fact that the Linux
{\tt rename()} system call does not support moving files from one disk to
another.  This means applications have to perform this complex
operation manually.  Earlier work on the SEA technique
identified XX steps required to
correctly perform such a move by examining the source code of the ``mv''
command.  With this knowledge, they
implemented a set of checkers to identify situations where one
or more of these steps were not carried out correctly.
When applied to real world applications,
these checkers were able to identify bugs
in many popular applications and libraries that offered file movement
capabilities.

Similar to the Unusual Filetype described in
Section~\ref{subsub:UnusualFiletype},
we first implemented the
set of checkers in CSlang.  Figure~\ref{lst:Cross-DiskMoveCSlang} shows one
such checker that ensures {\tt fstat} is used after a file is opened but
before it is moved.  This pattern indicates that an application may be
storing the {\tt inode} number of the file -- a step necessary to prevent a race
condition where the file is replaced during the move process.  When
we compare this checker to the Python version in
Figure~\ref{lst:Cross-DiskMovePython} many of the qualities we discussed
above are apparent.  The CSlang version is more concise and its meaning is
less obscured by boilerplate and state management code that makes up the
bulk of the Python version.

This exercise did expose one of CSlang's shortcomings.
The Python checker in Figure~\ref{lst:XattrsPython},
which ensures an application
preserves all of a file's extended attributes and re-applies them the
destination file after the move.
The difficulty creting this checker
in CSlang was due to two factors.
First, CSlang does not support looping with a
runtime-defined number of iterations.  This is necessary to capture all
calls to {\tt getxattr()}.
Further, CSlang does not support a list data structure to store the values
retrieved by such calls and ensure they have all been applied with a
corresponding call to {\tt setxattr()}.
We are evaluating these deficiencies and plan to address them in the
future.

\begin{figure}[H]
\centering
\begin{tabular}{c}
\begin{lstlisting}
\\ This is absolutely a fake listing that will be changed out for a real
\\ one!!  Preston -> Don't forget to do this!
#include "stdio.h"

int main() {
    printf("Hello world!\n");
    return 0;
};
\end{lstlisting}
\end{tabular}
\caption{One of the cross disk move checkers implemented in CSlang}
\label{lst:Cross-DiskMoveCSlang}
\end{figure}


\begin{figure}[H]
\centering
\begin{tabular}{c}
\begin{lstlisting}
\\ This is absolutely a fake listing that will be changed out for a real
\\ one!!  Preston -> Don't forget to do this!
#include "stdio.h"

int main() {
    printf("Hello world!\n");
    return 0;
};
\end{lstlisting}
\end{tabular}
\caption{One of the cross disk move checkers implemented in Python}
\label{lst:Cross-DiskMovePython}
\end{figure}

\subsection{Working with other formats}

While the above results are encouraging, we wanted to ensure that CSlang's
usefulness was not limited to system call manipulation.
A logical next step would be to test CSlang's capabilities when working
with a higher level, but similarly structured, activity stream format.
After some consideration we settled on JSONRPC and XMLRPC.  These formats
were ideal because they are well defined, popular, and both have well
supported parsing libraries or modules.

\preston{I'm not sure if this timing information stays in.}
With this decision made we set about implementing the modules necessary
to translate
both formats to and from CSlang's internal data representation as
discussed in Section XXX.  To get a rough idea of the amount of effort
involved we timed our work on XMLRPC support and found our initial
implementation took 3 hours and 32 minutes to complete.

\preston{I don't know if this ``Google as a popularity oracle'' idea is
going to fly...}
To see how well our new formats worked we decided to test applications that
used them in the spirit of the SEA technique.  We identified a set of
candidate popular applications by searching for the terms ``XMLRPC API''
and ``JSONRPC API'' using Google\footnote{Insert date and time here}.  Our
final set of test applications were chosen by ordering the results by search
ranking and removing entries that depended on special hardware or
commercial software.

\preston{Make some calls
pick some calls
Capture results
Run results through CSlang programs that do transformations
Run calls again
Capture with proxy
modify results based on output from cslang programs
see how application responds}




% To further ease the processing of new formats we added a generic CSV
% processor.  This processor consumes a CSV row by row and allows operations
% to be performed on each field.  The purpose of this capability is to allow
% users to quickly get useful work done at the expense of some rigor/type
% checking etc.


%\subsection{Function like stuff is great but can we do other things?}
%
%After our success in the above work we wanted to stretch CSlang to perform
%useful work in a significantly different domain.  We showed that CSlang
%could process common protocols used to communicate across networks but
%could we do something interesting with the network traffic itself.
%
%Using generic CSV support we processed incoming network traffic as recorded
%by sysdig.  We constructed CSlang programs that could take incoming network
%traffic, recognize a pattern and output a firewall rule to address it.
%
%At a high level this works as follows:
%Sysdig records network traffic, extracts the fields we are interested in,
%and outputs them as a CSV.  We use our generic CSV processor to read this
%representation of the network traffic and process it with a mutator.
%The mutator outputs new stream of CSV data that is handed to a shell
%script that transforms them into IPtables rules.
%
%While we were happy with the results of this effort there were some
%drawbacks.  Primarily, we do not try to generate an optimal set of rules
%for a given stream of input network traffic.  In many cases there are
%duplicate or unnecessary rules that would be undesirable in a final rule
%set.  Fortunately, other work as been done in the area of optimizing
%firewall rules so we are confident a post-processing pass could be put in
%place to mitigate this problem.


\subsection{CSlang's Performance}

It doesn't matter how useful a tool may be
if it takes too long to complete its work.
As a result, performance is a concern.  Though our implementation is
only a prototype, we wanted to make sure that its performance was not
overly slow.

We started by testing
CSlang
in an ideal setting.  For this test we constructed the program
shown in Figure~\ref{lst:SyntheticPerformance}
and used it to transform a specific
pattern of events in JSONRPC, and XMLRPC traces to
see how CSlang performed when processing each format.  We also varied the
size of each trace to get an idea of how total trace size impacted
performance.  The results of this effort can be seen in
Table~\ref{tbl:SyntheticPerformance}

\begin{figure}[H]
\centering
\begin{tabular}{c}
\begin{lstlisting}
\\ This is absolutely a fake listing that will be changed out for a real
\\ one!!  Preston -> Don't forget to do this!
#include "stdio.h"

int main() {
    printf("Hello world!\n");
    return 0;
};
\end{lstlisting}
\end{tabular}
\caption{CSlang program used }
\label{lst:SyntheticPerformance}
\end{figure}


\begin{figure}
  \begin{tabular}{|c|c|c|c|}
                & 1000 Events   & 10000 Events & 100000 Events \\
  Strace        & 2.3 sec FAKE  & 23 sec FAKE  & 230 sec FAKE  \\
  JSONRPC       & 1.7 sec FAKE  & 17 sec FAKE  & 170 sec FAKE  \\
  XMLRPC        & 3.0 sec FAKE  & 30 sec FAKE  & 300 sec FAKE  \\
\end{tabular}
\caption{Time in seconds to process the specified number of events of each
  format.}
\label{tbl:SyntheticPerformance}
\end{figure}

As can be seen in Table~\ref{tbl:SyntheticPerformance},
the results indicate that CSlang is able to
process large synthetic traces in a reasonable amount of time.  Further,
the time required to process a trace grows in proportion to the number of
events being processed.
It is reasonable to conclude that the largest
factor behind our recorded processing times is the speed with which the
traces can be read from disk.  The time required to advance the state of
the underlying CSlang mutator is relatively small by comparison.

The second part of our performance evaluation
focused on identifying specific
patterns within real world system call traces.  We recorded our test traces
from three popular web servers - Apache, Nginx, and Lighttpd. These
were chosen because they are widely deployed and sufficiently
complex to offer a representation of what CSlang might encounter under
realistic use cases.

Our test operated as follows.  First, each web server was configured to
serve a static web page while being recorded using {\tt strace}.  Next, we
requested the page from each server using {\tt wget}.  The strace
recordings were then processed using the CSlang program from
Figure~\ref{lst:RealWorldPerformance},  which
identified the sequence of system calls that implement
a web server's request handling
loop.  Table~\ref{tbl:RealWorldPerformance}
shows the times in seconds required to perform this identification on each
web server as well as the total number of system calls in each trace.

\begin{figure}
  \begin{tabular}{|c|c|c}
                & Time in Sec. & Num. Syscalls.\\
  Apache        & 1.7 sec FAKE & 1700 FAKE      \\
  Nginx         & 2.3 sec FAKE & 2300 FAKE      \\
  Lighttpd      & 0.9 sec FAKE & 850  FAKE      \\
\end{tabular}
\caption{Time in seconds to process the specified number of events of each format.}
\label{tbl:RealWorldPerformance}
\end{figure}

\begin{figure}[H]
\centering
\begin{tabular}{c}
\begin{lstlisting}
\\ This is absolutely a fake listing that will be changed out for a real
\\ one!!  Preston -> Don't forget to do this!
#include "stdio.h"

int main() {
    printf("Hello world!\n");
    return 0;
};
\end{lstlisting}
\end{tabular}
\caption{CSlang program used for real world performance testing}
\label{lst:RealWorldPerformance}
\end{figure}

The results in Table~\ref{tbl:RealWorldPerformance} closely align with
those in Table~\ref{tbl:SyntheticPerformance}.  This lends further
credibility to our assertions that CSlang's performance is closely tied to
disk throughput, with
the process of evaluating each system call and appropriately advancing the
mutator adding little additional overhead.
