\section{Evaluation}
\label{SEC:evaluation}

With our prototype in hand we organized a set of
evaluations that would let us know if the CSlang would be effective
in real world situations.
We designed our tests to answer the following questions:

\begin{itemize}

    % Re-implementing CS anomalies
  \item{Can CSlang express the sorts of anomalies used by SEA to identify
    bugs?}

    % Extending to support RPC formats
  \item{How easy is it to extend CSlang to support activity representations
    other than system calls?}

    % Dornhackl et al. defining maliciousness
  \item{What sorts of problems can be addressed by employing CSlang on
  non-system-call activity representations?}

    % Performance information
  \item{Can CSlang process input streams in a reasonable amount of time?}

\end{itemize}


\subsection{Expressing SEA Anomalies}
\label{sub:SEAAnomalies}
Given that this work was motivated
in large part
by the effectiveness of the SEA technique,
our first test of CSlang was using it to reproduce the anomalies described
in the original paper.
We wanted to ensure that
the language we developed
would be sufficiently powerful
to describe the anomalies the
SEA research team used to
find bugs.
Specifically,
we set out to test CSlang's ability to recreate
the study's Unusual Filetype mutator,
and its Cross-disk file move checkers, which were used to identify
the bulk of
the bugs that were found.
Our hope was that by using CSlang we could eliminate boiler plate code,
save effort by handling common tasks automatically, and improve reliability
by providing a structured way to modify and output system call sequences.

\begin{figure}[H]
\centering
\begin{tabular}{c}
\begin{lstlisting}
\\ This is absolutely a fake listing that will be changed out for a real
\\ one!!  Preston -> Don't forget to do this!
#include "stdio.h"

int main() {
    printf("Hello world!\n");
    return 0;
};
\end{lstlisting}
\end{tabular}
\caption{Unusual filetype mutator in CSlang}
\label{lst:UnusualFiletypeCSlang}
\end{figure}

\subsubsection{Creating the Unusual Filetype Mutator}
\label{subsub:UnusualFiletype}
For the first phase of this work,
we used CSlang to implement an ``Unusual Filetype''
mutator.
This mutator, presented in
Figure~\ref{lst:UnusualFiletypeCSlang},
should take an input trace
that contains a call to either {\tt stat()},
{\tt fstat()},
or {\tt lstat()}
and modify the call's result data structure such
that its {\tt ST\_MODE} member will contain one of the values from
Table~\ref{tbl:ST_MODEValues}.  As can be seen in
Figure~\ref{lst:UnusualFiletypeCSlang}, CSlang's semantics mean such an
operation can be captured with only a handful of lines of code.  In the
figure
lines XX-XX define what {\tt stat()}, {\tt fstat()}, and {\tt
lstat()} calls look like and which parameter contains the result buffer.
Line YY generates an accepting state that, when entered, produces an output
system call with a modified value in the return structure's {\tt st\_mode}
field.  Such output can then be used to modify the results of a running
application's system calls in order to carry out the remaining steps of the
SEA technique.

%\begin{figure}
%  \begin{tabular}{|c|c}
%  Value    & Meaning          \\
%  IF\_BLK  & Block Device     \\
%  IF\_CHR  & Character Device \\
%  IF\_SOCK & Socket           \\
%\end{tabular}
%\caption{ST\_MODE values}
%\label{tbl:ST_MODEValues}
%\end{figure}

CSlang's advantages are made even more obvious when the CSlang Unusual
Filetype mutator is compared to a program that implements the same
functionality in a general purpose programming language like Python.
Figure~\ref{lst:UnusualFiletypePython} shows an excerpt from a XX line
Python program taken from the SEA paper's CrashSimulator that performs the
above operation.  Comparing this listing to
Figure~\ref{lst:UnusualFiletypeCSlang} shows several key differences:

\textit{Minimal boilerplate code:} The CSlang program lacks the boilerplate
code associated with
reading an input trace, managing mutator state, and producing output.
This is possible because CSlang's capabilities are narrowly defined to
only describe the states and operations of a mutator.  This means these
functions can be generically implemented within CSlang's core eliminating
the need for users to do so manually.

\textit{No code required to filter out uninteresting calls:}
CSlang's user does
not need to write any code to exclude system
calls outside of the desired set.  Each statement defines a new state with
incoming and outgoing transitions configured such that any system calls not
dealt with in the CSlang program are ignored.

\textit{Easy to modify call contents:}  CSlang's operators make it
trivial to change components of a system call
and produce output without having to regenerate the remainder of its
parameters.
This is a far cry
from the Python program which relies on manual, fragile string manipulation
to achieve the same effect.


\begin{figure}[H]
\centering
\begin{tabular}{c}
\begin{lstlisting}
\\ This is absolutely a fake listing that will be changed out for a real
\\ one!!  Preston -> Don't forget to do this!
#include "stdio.h"

int main() {
    printf("Hello world!\n");
    return 0;
};
\end{lstlisting}
\end{tabular}
\caption{Python code that implements the unusual filetype mutator}
\label{lst:UnusualFiletypePython}
\end{figure}

\subsubsection{Creating the Cross-Disk Move Checkers}

The second phase of this work involved the recreation of a set of
``checkers'' that could examine an application as it moved a file from one
disk to another and report whether or not the operation was carried
out correctly.  These checkers took advantage of the fact that the Linux
{\tt rename()} system call does not support moving files from one disk to
another.  This means applications have to perform this complex
operation manually.  Earlier work on the SEA technique
identified XX steps required to
correctly perform such a move by examining the source code of the ``mv''
command.  With this knowledge, they
implemented a set of checkers to identify situations where one
or more of these steps were not carried out correctly.
When applied to real world applications,
these checkers were able to identify bugs
in many popular applications and libraries that offered file movement
capabilities.

Similar to the Unusual Filetype described in
Section~\ref{subsub:UnusualFiletype},
we first implemented the
set of checkers in CSlang.  Figure~\ref{lst:Cross-DiskMoveCSlang} shows one
such checker that ensures {\tt fstat} is used after a file is opened but
before it is moved.  This pattern indicates that an application may be
storing the {\tt inode} number of the file -- a step necessary to prevent a race
condition where the file is replaced during the move process.  When
we compare this checker to the Python version in
Figure~\ref{lst:Cross-DiskMovePython} many of the qualities we discussed
above are apparent.  The CSlang version is more concise and its meaning is
less obscured by boilerplate and state management code that makes up the
bulk of the Python version.

This exercise did expose one of CSlang's shortcomings.
The Python checker in Figure~\ref{lst:XattrsPython},
which ensures an application
preserves all of a file's extended attributes and re-applies them the
destination file after the move.
The difficulty creting this checker
in CSlang was due to two factors.
First, CSlang does not support looping with a
runtime-defined number of iterations.  This is necessary to capture all
calls to {\tt getxattr()}.
Further, CSlang does not support a list data structure to store the values
retrieved by such calls and ensure they have all been applied with a
corresponding call to {\tt setxattr()}.
We are evaluating these deficiencies and plan to address them in the
future.

\begin{figure}[H]
\centering
\begin{tabular}{c}
\begin{lstlisting}
\\ This is absolutely a fake listing that will be changed out for a real
\\ one!!  Preston -> Don't forget to do this!
#include "stdio.h"

int main() {
    printf("Hello world!\n");
    return 0;
};
\end{lstlisting}
\end{tabular}
\caption{One of the cross disk move checkers implemented in CSlang}
\label{lst:Cross-DiskMoveCSlang}
\end{figure}


\begin{figure}[H]
\centering
\begin{tabular}{c}
\begin{lstlisting}
\\ This is absolutely a fake listing that will be changed out for a real
\\ one!!  Preston -> Don't forget to do this!
#include "stdio.h"

int main() {
    printf("Hello world!\n");
    return 0;
};
\end{lstlisting}
\end{tabular}
\caption{One of the cross disk move checkers implemented in Python}
\label{lst:Cross-DiskMovePython}
\end{figure}

\subsection{Working with other formats}

While the above results are encouraging, we wanted to ensure that CSlang's
usefulness was not limited to system call manipulation.
A logical next step would be to test CSlang's capabilities when working
with a higher level, but similarly structured, activity stream format.
After some consideration we settled on JSONRPC and XMLRPC.  These formats
were ideal because they are well defined, popular, and both have well
supported parsing libraries or modules.

\preston{I'm not sure if this timing information stays in.}
With this decision made we set about implementing the modules necessary
to translate
both formats to and from CSlang's internal data representation as
discussed in Section XXX.  To get a rough idea of the amount of effort
involved we timed our work on XMLRPC support and found our initial
implementation took 3 hours and 32 minutes to complete.

\preston{I don't know if this ``Google as a popularity oracle'' idea is
going to fly...}
To see how well our new formats worked we decided to test applications that
used them in the spirit of the SEA technique.  We identified a set of
candidate popular applications by searching for the terms ``XMLRPC API''
and ``JSONRPC API'' using Google\footnote{Insert date and time here}.  Our
final set of test applications were chosen by ordering the results by search
ranking and removing entries that depended on special hardware or
commercial software.

\preston{Make some calls
pick some calls
Capture results
Run results through CSlang programs that do transformations
Run calls again
Capture with proxy
modify results based on output from cslang programs
see how application responds}

\subsection{Utilizing CSlang's Flexibility}
In addition to novel formats, we wanted to see if CSlang could be used to
represent proven-useful models from other work.  One candidate for this
effort is the work on describing malicious behavior done by Dornhackl et
al. in 2014~\ref{Dornhackl2014}.  This work improves upon static malicious
behavior detection using signatures by creating formal models that can
detect misbehavior in an application's dynamic activity.  This is done
using two models: one that describes malicious activity in the form of a
series of tasks and a second that maps these tasks onto the concrete
Windows API calls required to carry out these tasks.

CSlang is particularly well suited to implementing the second model.  This
requires a mechanism for first grouping a set of similar API calls
into a single operation and then describing a malicious task in terms of
these aggregate operations.  CSlang supports the former using variants.
For example, the work proposes grouping the API calls that may be used to
open a Windows registry key as is shown in Figure~\ref{lst:DornhacklOpen}.

\begin{figure}[H]
\centering
\begin{tabular}{c}
\begin{lstlisting}
OPEN => RegOpenKeyA NtOpenKey
  | RegOpenKeyW NtOpenKey
  | RegOpenKeyExA NtOpenKey
  | RegOpenKeyExW NtOpenKey
\end{lstlisting}
\end{tabular}
\caption{Grouping of Windows API calls for opening or creating a Windows
  registry key into an OPEN operation as per Dornhackl et al.}
\label{lst:DornhacklOpen}
\end{figure}


In the above grammar, each symbol beginning with ``Reg'' represents a user
API that opens or creates a registry key.  {\tt NtOpenKey} always follows
each of these calls because it is the underlying ``native'' call that
Windows makes to actually perform the operation.
The grouping and execution semantics for this operation can be expressed
in CSlang as shown in Figure~\ref{lst:CSlangOpenReg}.


\begin{figure}[H]
\centering
\begin{tabular}{c}
\begin{lstlisting}
 open {RegOpenKeyA ...}
    | {NtOpenKey ... }
    | {RegOpenKeyW ...}

  type NtOpenKey {...};

  open({...});
  NtOpenKey({...});
\end{lstlisting}
\end{tabular}
  \caption{Abstract CSlang program (with parameters
  omitted) that groups the Windows API calls responsible for opening or
  creating a Windows registry key into an open operation.  It also shows
  how the requirement that NtOpenKey follow any of these calls can be
  captured.}
\label{lst:CSlangOpenReg}
\end{figure}

Dornhackl et al. used this strategy to describe a pattern that, if
detected, would indicate
a Windows registry key was being installed
that would cause some malicious action
the next time the machine was restarted.  We can use CSlang to group the
Windows API calls into the same operations as the original work and
construct a program that could perform this detection (assuming CSlang were
extended to support Windows).  Such a program appears in
Figure~\ref{lst:CSlangRegDetect}.  This program groups API calls into OPEN,
SET, and CLOSE operations and searches for a pattern that
indicates
an application is
setting an autostart key.  The CSlang program is further able to express
that the pattern must appear for a specific registry key using the value
stored in the ``regkey'' register.

\begin{figure}[H]
\centering
\begin{tabular}{c}
\begin{lstlisting}
Program goes here
\end{lstlisting}
\end{tabular}
  \caption{This listing shows an abstract CSlang program (with parameters
  omitted) that detects situations where an application is maliciously
  installing an ``autostart'' Windows registry key.  It does so by
  implementing the pattern described by Dornhackl et al.  Unimportant
  parameters are omitted and the number of API calls in each group has been
  reduced in order to save space.}
\label{lst:CSlangRegDetect}
\end{figure}


\subsection{CSlang's Performance}

It doesn't matter how useful a tool may be
if it takes too long to complete its work.
Though our implementation is
only a prototype, we wanted to make sure that its performance was not
overly slow.
Our performance evaluation
is focused on the time required
to identify specific
patterns within real world system call traces.
We recorded test traces
from three popular network applications -
NCat,
Python's http.server,
and Nginx.
These
were chosen because they are widely used and
offer increasing levels of complexity against which we can evaluate
CSlang's effectiveness.

Our test operated as follows.  The applications were configured to service
a simple piece of content (a single string in the case of NCat) and were
recorded using {\tt strace} while handling a request from a remote client.
The strace
recordings were then processed using the CSlang program from
Figure~\ref{lst:RealWorldPerformance},  which
identified the sequence of system calls that implement
a server's request handling
loop.  Table~\ref{tbl:RealWorldPerformance}
shows the times in seconds required to perform this identification on each
web server as well as the total number of system calls in each trace.

\begin{figure}
  \begin{tabular}{|c|c|c}
                & Time in Sec. & Num. Syscalls.\\
  http.server   & 1.7 sec FAKE & 1700 FAKE      \\
  NCat          & 2.3 sec FAKE & 2300 FAKE      \\
  wget          & 0.9 sec FAKE & 850  FAKE      \\
\end{tabular}
\caption{Time in seconds to process the specified number of events of each format.}
\label{tbl:RealWorldPerformance}
\end{figure}

\begin{figure}[H]
\centering
\begin{tabular}{c}
\begin{lstlisting}
\\ This is absolutely a fake listing that will be changed out for a real
\\ one!!  Preston -> Don't forget to do this!
#include "stdio.h"

int main() {
    printf("Hello world!\n");
    return 0;
};
\end{lstlisting}
\end{tabular}
\caption{This CSlang program matches patterns where a server application
  accepts a connection, receives a request, sends a response, and closes
  the connection.  The program uses variants to handle cases where
  applications use different system calls to perform some common action
  (e.g. receiving data from a socket)}
\label{lst:RealWorldPerformance}
\end{figure}

The results in Table~\ref{tbl:RealWorldPerformance} show that, as expected,
CSlang's
processing time increases in line with the total number of system calls
present in a recording.  We anticipate that much of this processing cost is
associated with setting up a Python execution environment and that a more
optimized implementation could improve performance gains in this area.
Further,
it is likely that CSlang's performance is closely tied to
disk throughput,
and that advancing the mutator
as each system call is evaluated
adds little additional overhead.
A condition with varying disk
speeds could be designed to confirm this suspicion.  As a whole, our
results indicate that CSlang's performance is not a limiting factor to its
usage in real-world situations.
