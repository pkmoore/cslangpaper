\section{Evaluation}
\label{SEC:evaluation}

Once we had an implementation of PORT, we designed a set of experiments to evaluate its  effectiveness in real world situations.
Specifically, we aim to answer the following questions:

\begin{itemize}

    % Re-implementing CS anomalies
  \item{Can PORT express the anomalies used by SEA to identify bugs?}

    % Extending to support RPC formats
  \item{How easy is it to extend PORT to support activity representations
    other than system calls?}

    % Dornhackl et al. defining maliciousness
  \item{What problems can be addressed by employing PORT on
  non-system-call activity representations?}

    % Performance information
  \item{Can PORT process input streams in a reasonable amount of time?}

\end{itemize}


\subsection{Expressing SEA Anomalies}
\label{sub:SEAAnomalies}
Given that this work is motivated
in large part
by a desire to expand the utility of the SEA technique,
our first experiment aims to reproduce the anomalies described
in~\cite{DBLP:conf/issre/MooreCFW19}.
Specifically,
we test PORT's ability to recreate
the study's unusual file type mutator,
and its cross-disk file move checkers, which were used to identify
the bulk of the bugs that were found.
% Our hope was that by using PORT we could eliminate boiler plate code,
% save effort by handling common tasks automatically, and improve reliability
% by providing a structured way to modify and output system call sequences.



\subsubsection{Creating the Unusual File type Mutator}
\label{subsub:UnusualFiletype}
For the first part of this experiment,
we used PORT to implement an ``unusual file type''
mutator.
As illustrated in Figure~\ref{lst:SEAListings},this mutator
takes an input trace
that contains a call to either {\tt stat()},
{\tt fstat()},
or {\tt lstat()}
and modifies its result data structure so
its {\tt ST\_MODE} member will indicate an unusual file type.
As can be seen in
Figure~\ref{lst:SEAListings}, this task can be expressed with only a few lines of PORT code.  In the figure,
lines 1 through 4 define what {\tt stat()}, {\tt fstat()}, and {\tt
lstat()} calls look like, and which parameter contains the result buffer.
Line 6 generates an accepting state that, when entered, produces an output
system call with a modified value in the return structure's {\tt st\_mode}
field.  The output can then be used to modify the results of a running
application's system calls in order to carry out the remaining steps of the
SEA technique.

\begin{figure}
\centering
\begin{lstlisting}[basicstyle=\ttfamily\scriptsize]
event fstat {filedesc: Numeric@0};
event stat {filename: String@0};
event open {filename: String@0, filedesc: Numeric@ret};

stat({filename: fn});
open({filename: ?fn, filedesc: fd});
fstat({fildesc: ?fd});
\end{lstlisting}
\begin{lstlisting}[basicstyle=\ttfamily\scriptsize]
event Statbuf {mode: String@2};
event anystat {stat sb: Statbuf@1}
        | {lstat sb: Statbuf@1} 
        | {fstat sb: Statbuf@1};
anystat({sb: {mode: -> "st_mode=S_IFBLK"}});
\end{lstlisting}
\caption{The left listing contains a
PORT program that can detect whether a file was replaced as it was copied.
The right listing shows a program that
identifies a \texttt{stat}, \texttt{lstat}, or \texttt{fstat} call and modifies
  the \lstinline+ST\_MODE+ member of its \lstinline+statbuf+ output parameter to contain the value
  \lstinline+"S\_IFBLK"+. This indicates that the file being examined is a block device rather than a regular file.}
\label{lst:SEAListings}
\end{figure}

The original implementation of this mutator in~\cite{DBLP:conf/issre/MooreCFW19} consisted of 55 lines
of Python code, much of it error-prone state management code. While this code was needed, it harmed
readability and maintainability.
When compared to the original mutator, it became apparent that there were
several major advantages
to using
PORT:

\textit{Minimal boilerplate code:} Because PORT's capabilities are narrowly defined to
only describe the states and operations of a transducer, it lacks the boilerplate
code associated with general purpose languages. No code is needed for 
reading an input trace, managing mutator state, and producing output.
As a result,
functions can be generically implemented within PORT's core, eliminating
the need for users to do so manually.

\textit{No code required to filter out uninteresting calls:}
In PORT, there is no
need to explicitly exclude system
calls outside of the desired set.  Each statement defines a new state with
incoming and outgoing transitions configured to ignore any system calls not
dealt with in the PORT program.

\textit{Easy to modify call contents:}  PORT's operators make it
easy to change only those parameters  of a system call
 needed to produce output.
This is a far cry
from the Python program, which relies on manual and fragile string manipulation.

\subsubsection{Supporting Cross-Disk Move Checkers}

In the second part of this experiment we tested whether PORT can
implement the ``checkers'' used in SEA to determine if an
application can correctly move a file from one disk to another.
This task is a common source of bugs in Linux applications. As the
Linux
{\tt rename()} system call does not support moving files from one disk to
another,
applications must perform this complex
operation themselves.
Moore et al. identified the steps required to
correctly perform such a move by examining the source code of the ``mv''
command. The team then implemented a set of checkers to identify situations where an application does not carry out one
of these steps correctly. 
In real world applications,
these checkers were able to identify bugs
in many popular applications and libraries that offer file movement
capabilities.

We evaluated each of the four checkers listed in Moore et al.'s work and
determined that PORT could implement three of them.
Figure~\ref{lst:SEAListings} shows our PORT implementation of
the ``File Replaced During Copy'' checker
that ensures {\tt fstat} is used after a file is opened but
before it is moved.  This pattern indicates that an application may be
storing the {\tt inode} number of the file -- a step that prevents a race
condition where the file is replaced during the move process.
Comparing it to the
original SEA checker,
which consisted of 45 lines of difficult to read and maintain Python code,
shows many of the same deficiencies as the unusual file type
mutator above.
The PORT version is much more concise and its meaning is
less obscured by boilerplate and state management code.

This exercise did expose one of PORT's shortcomings.  Specifically,
we found that PORT cannot currently implement the ``Extended File
Attributes'' checker, which
 ensures that an application
preserves all of a file's extended attributes and re-applies them after the move.
PORT's lack of a list data structure made it difficult to create this checker as a
list is required to capture the values {\tt getxattr()}
and ensure they have all been applied with a
corresponding call to {\tt setxattr()}.
Though we are considering such a feature for future implementation,
we do not currently support it because such an extension could
hurt program clarity and make it harder to reason about
mutator behavior.


\subsection{Extending PORT to Other Activity Representations}

In order to get an idea of PORT’s extensibility we decided to see if we could use it to find and transform useful patterns in another domain.
Our search lead us to USB, which seemed a good fit because of its ubiquity and reliance on numerous parties correctly implementing a standard protocol.
Using PORT on streams of USB activity required that we implement an appropriate transformer and develop some way to capture communications between USB devices.
For the latter, we used Wireshark because of its excellent traffic capture and dissection capabilities~\ref{wireshark}.
We developed a transformer that could consume the JSON representation of a stream of frames as exported by Wireshark.
Together, these two components allowed us to write PORT programs that could both identify patterns and transform streams of USB frames.

As a test scenario, we settled upon the recent type of usb-based attack known as BADUSB~\ref{badusb}.
These attacks utilize small USB devices that resemble thumb drives. However, rather than storing files, when plugged into a targeted computer, these devices register themselves as human interface devices and rapidly send keystrokes to execute malicious commands before a human is able to react.
Our goal was to construct PORT programs to recognize these attacks within a recording of a machine’s USB traffic and simulate them by transforming an innocent USB recording into one containing such an attack.
The latter could be replayed using a device similar to those used in actual attacks in order to assess whether or not a computer’s defensive measures (e.g. antivirus software or specialized anti-BADUSB programs) are able detect the attacks. 

The PORT program in figure <fig> is an example of a program that detects a USB device attempting to execute powershell
in a mode where its security policy is bypassed.
This is a common starting point for BADUSB attacks that seek to execute complex payloads, such as powershell scripts.
This program detects USB frames that contain a sequence of ``scan codes'' in which a series of keystrokes spell out ``powershell -Exec bypass.''
Detecting this string is critical because it explicitly disables security controls, a step that should only be taken under special circumstances.
We were able to use this program to detect the target sequence in streams of USB traffic recorded from a real computer using a standard USB keyboard.

A more advanced example of PORT's capabilities with USB streams involves simulating a BADUSB attack, as demonstrated in figure <FIG>.
In a similar fashion to our detection program, this program identifies USB human interface device frames, and then transforms the scan codes they contain to yield key presses that spell out ``powershell -Exec bypass.''
In this way, the program can use an innocent stream to create a malicious one capable of driving a BADUSB attack. In doing so, a user can determine how well a system's defenses can detect and prevent such a scenario.


\subsection{PORT's Performance}

%It doesn't matter how useful a tool may be
%if it takes too long to complete its work.
%Though our implementation is
%only a prototype, we wanted to make sure that its performance was not
%overly slow.
Our final experiment evaluates the
time required for our current implementation
to identify specific
patterns within real-world system call traces.
We chose eight widely used network applications that offered a sufficient level of complexity
and recorded test traces using the following 
experimental setup.
Five of the applications are clients that operate by connecting to an appropriate service. They were recorded as they made this connection and completed a small request (e.g. transmitting or receiving a file).
Three of the applications were servers.  As such, they were recorded as they accepted a connection from an appropriate client and serviced a small request.
These recordings were made with strace
and then processed using a PORT program
The program in question
identifies the sequence of system calls that implement
a client or server's request handling loop\footnote{Recordings are pre-processed to remove system calls
related to executable loading and process creation.}.  Table~\ref{tbl:RealWorldPerformance}
shows the times in seconds required to perform this processing.
Each execution timed 1, 10, and 100 times in order to mitigate the
possibility of external factors influencing our measurements.

\begin{figure}[t]
\centering
  \begin{tabular}{|c|l|l|l|l}
                & 1 Exe. & 10 Exe. & 100 Exe. & Length\\
              \hline
  rsync client  & 0.128       & 1.257         & 12.067         & 274 \\
  ftp client    & 0.200       & 1.858         & 18.616         & 891 \\
  scp client    & 0.172       & 1.756         & 17.262         & 490 \\
  ssh client    & 0.232       & 2.273         & 22.546         & 850 \\
  telnet client & 0.114       & 0.958         & 9.132          & 23  \\
  http.server   & 0.104       & 0.914         & 8.823          & 43  \\
  ncat server   & 0.115       & 0.933         & 9.140          & 43  \\
  socat server  & 0.118       & 1.124         & 10.321         & 71  \\
\end{tabular}
\caption{Time in seconds to process the listed number of events.  The 2nd - 4th
columns list times required to complete 1, 10, and 100 executions.  Column 5
notes the number of system calls in the trace being processed.}
\label{tbl:RealWorldPerformance}
\end{figure}

%\begin{figure}
%\centering
%\begin{tabular}{c}
%\begin{lstlisting}[gobble=2]
%  event accept { accept fd: Number@ret}
%             | { accept4 fd: Number@ret};
%  event anyrecv { recvfrom fd: Number@0}
%    | { read fd: Number@0} | { recv fd: Number@0};
%  event anysend {sendto fd: Number@0}
%    | { write fd: Number@0} | { send fd: Number@0};
%  event close {fd: Number@0};
%
%  accept({fd: storefd});
%  anyrecv({fd: ?storefd});
%  anysend({fd: ?storefd});
%  close({fd: ?storefd});
%\end{lstlisting}
%\end{tabular}
%\caption{A PORT program that matches patterns where a server application
%  accepts a connection, receives a request, sends a response, and closes
%  the connection.  The program uses variants to handle cases where
%  applications use different system calls to perform some common action
%  (e.g. receiving data from a socket).}
%\label{lst:RealWorldPerformance}
%\end{figure}

The results in Table~\ref{tbl:RealWorldPerformance} show that
PORT's
processing time increases in line with the total number of system calls
in the recording.  We anticipate that much of this processing cost is
associated with setting up the Python execution environment and that a more
optimized implementation could improve performance gains in this area.
Further,
it is likely that PORT's performance is closely tied to
disk throughput,
and that advancing the transducer
as each system call is evaluated
adds little additional overhead.
%A condition with varying disk speeds could be designed to confirm this suspicion.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "paper"
%%% End:
