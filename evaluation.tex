\section{Evaluation}
\label{SEC:evaluation}

With our prototype in hand, we designed a set of experiments to evaluate
whether PORT is effective in real world situations.
Specifically, we aim to answer the following questions:

\begin{itemize}

    % Re-implementing CS anomalies
  \item{Can PORT express the anomalies used by SEA to identify bugs?}

    % Extending to support RPC formats
  \item{How easy is it to extend PORT to support activity representations
    other than system calls?}

    % Dornhackl et al. defining maliciousness
  \item{What problems can be addressed by employing PORT on
  non-system-call activity representations?}

    % Performance information
  \item{Can PORT process input streams in a reasonable amount of time?}

\end{itemize}


\subsection{Expressing SEA Anomalies}
\label{sub:SEAAnomalies}
Given that this work is motivated
in large part
by the effectiveness of the SEA technique,
our first experiment aims to reproduce the anomalies described
in~\cite{DBLP:conf/issre/MooreCFW19}.
We want to ensure that
the language is sufficiently expressive
to describe the anomalies the
SEA research team used to
find bugs.
Specifically,
we test PORT's ability to recreate
the study's unusual file type mutator,
and its cross-disk file move checkers, which were used to identify
the bulk of the bugs that were found.
% Our hope was that by using PORT we could eliminate boiler plate code,
% save effort by handling common tasks automatically, and improve reliability
% by providing a structured way to modify and output system call sequences.



\subsubsection{Creating the Unusual File type Mutator}
\label{subsub:UnusualFiletype}
For the first part of this experiment,
we used PORT to implement an ``unusual file type''
mutator.
This mutator, presented in
Figure~\ref{lst:UnusualFiletypePORT},
takes an input trace
that contains a call to either {\tt stat()},
{\tt fstat()},
or {\tt lstat()}
and modifies the call's result data structure such
that its {\tt ST\_MODE} member will contain a value
that indicates an unusual file type.
As can be seen in
Figure~\ref{lst:UnusualFiletypePORT}, this task can be expressed with only a few lines of PORT code.  In the figure,
lines 1 through 4 define what {\tt stat()}, {\tt fstat()}, and {\tt
lstat()} calls look like and which parameter contains the result buffer.
Line 6 generates an accepting state that, when entered, produces an output
system call with a modified value in the return structure's {\tt st\_mode}
field.  The output can then be used to modify the results of a running
application's system calls in order to carry out the remaining steps of the
SEA technique.

\begin{figure}
\centering
\begin{tabular}{c}
\begin{lstlisting}
event Statbuf {mode: String@2};
event anystat {stat sb: Statbuf@1}
        | {lstat sb: Statbuf@1} | {fstat sb: Statbuf@1};
anystat({sb: {mode: ->"st\_mode=S\_IFBLK"}});
\end{lstlisting}
\end{tabular}
\caption{This program identifies a \texttt{stat}, \texttt{lstat}, or \texttt{fstat} call and modifies
  the \lstinline+ST\_MODE+ member of its \lstinline+statbuf+ output parameter to contain the value
  \lstinline+"S\_IFBLK"+. This indicates that the file being examined is a block device
  rather than a regular file.}
\label{lst:UnusualFiletypePORT}
\end{figure}

The original implementation of this mutator in~\cite{DBLP:conf/issre/MooreCFW19} consisted of 55 lines
of Python code.
When we compared our PORT code to the original mutator,
several major advantages
of writing a mutator using
PORT rather than a general purpose programming language
became apparent:

\textit{Minimal boilerplate code:} The PORT program lacks the boilerplate
code associated with
reading an input trace, managing mutator state, and producing output.
This is possible because PORT's capabilities are narrowly defined to
only describe the states and operations of a transducer.  This means these
functions can be generically implemented within PORT's core, eliminating
the need for users to do so manually.

\textit{No code required to filter out uninteresting calls:}
In PORT, there is no
need to write any code to exclude system
calls outside of the desired set.  Each statement defines a new state with
incoming and outgoing transitions configured such that any system calls not
dealt with in the PORT program are ignored.

\textit{Easy to modify call contents:}  PORT's operators make it
easy to change components of a system call
and produce output without having to manually reassemble the remainder of its
parameters.
This is a far cry
from the Python program, which relies on manual and fragile string manipulation
to achieve the same effect.

\subsubsection{Supporting Cross-Disk Move Checkers}

In the second part of this experiment we test whether PORT can be used to
implement the ``checkers'' used in the SEA work to determine if an
application can correctly move a file from one disk to another.
This task is a common source of bugs in Linux applications as the
Linux
{\tt rename()} system call does not support moving files from one disk to
another, leaving
applications to perform this complex
operation themselves.
Moore et al. identified the steps required to
correctly perform such a move by examining the source code of the ``mv''
command and implemented a set of checkers to identify situations where one
of these steps is not carried out correctly by an application.
When applied to real world applications,
these checkers were able to identify bugs
in many popular applications and libraries that offered file movement
capabilities.

We evaluated each of the checkers and decided that the ``File Replaced
During Copy'' checker was a good candidate.
Figure~\ref{lst:FileReplacedPORT} shows our PORT implementation of this
checker, which
ensures that {\tt fstat} is used after a file is opened but
before it is moved.  This pattern indicates that an application may be
storing the {\tt inode} number of the file -- a step necessary to prevent a race
condition where the file is replaced during the move process.
Comparing this checker to the
original SEA checker,
which consisted of 45 lines of Python,
shows that many of the same deficiencies that effected the unusual file type
mutator above are present.
The PORT version is much more concise and its meaning is
less obscured by boilerplate and state management code that makes up the
bulk of the Python version.

This exercise did expose one of PORT's shortcomings.  Specifically,
we found that PORT cannot currently implement the ``Extended File
Attributes'' checker.
This checker ensures that an application
preserves all of a file's extended attributes and re-applies them the
destination file after the move.
The difficulty creating this checker
in PORT was due to two factors.
First, PORT does not support looping with a
runtime-defined number of iterations.  This is necessary to capture all
calls to {\tt getxattr()}.
Further, PORT does not support a list data structure to store the values
retrieved by such calls and ensure they have all been applied with a
corresponding call to {\tt setxattr()}.
We are evaluating these deficiencies and plan to address them in the
future.

\begin{figure}
\centering
\begin{tabular}{c}
\begin{lstlisting}
event fstat {filedesc: Numeric@0};
event stat {filename: String@0};
evnt open {filename: String@0, filedesc: Numeric@ret};

stat({filename: fn});
open({filename: ?fn, filedesc: fd});
fstat({fildesc: ?fd});
\end{lstlisting}
\end{tabular}
\caption{PORT program for checking whether an application can detect whether a file was replaced during copying.}
\label{lst:FileReplacedPORT}
\end{figure}

\subsection{Extending PORT to Other Activity Representations}

While the above results are encouraging, we wanted to ensure that PORT's
usefulness was not limited to system call manipulation.
A logical next step would be to test PORT's capabilities when working
with a higher level, but similarly structured, activity representation.
After some consideration we settled on JSONRPC and XMLRPC.  These formats
were ideal because they are well defined, popular, and both have well
supported parsing libraries or modules.

To evaluate PORT's ability to work with these representations we
constructed transformer modules that could convert these formats into our
intermediate data format.
We tested our implementation by writing PORT programs that could modify
activity streams similar to the examples presented in the JSONRPC
2.0~\cite{jsonspec} and XMLRPC~\cite{xmlspec}
specifications.  One such program is shown in
Figure~\ref{lst:JSONProgram}.  This program matches a pattern of ``test''
and ``update'' calls and, if the pattern is found, the final update call's
parameters are replaced with the contents of two registers.

Support for JSONRPC required a handful of hours of effort, and our
XMLRPC implemention,
which we precisely timed, was completed in three
hours and thirty-two minutes.  Based on the ease and speed with which we
ere able to complete these additions we are confident that PORT can be
quickly adapted to support new activity representations as required.

\begin{figure}[H]
\centering
\begin{tabular}{c}
\begin{lstlisting}
event update {up1: Number@0, up2: Number@1};
event test {tp1: Number@0, tp2: String@1};
update({up1: pone, up2: ptwo});
test({tp1: 45, tp2: "alpha"});
update({up1: ->999, up2: ->888});
\end{lstlisting}
\end{tabular}
\caption{This PORT program matches a pattern of JSONRPC calls to
  ``update'' and ``test.''  If the pattern is identified, the final call to
  update is modified so that its first two parameter values are replaced
  with the values stored in the outone and outtwo registers.}
\label{lst:JSONProgram}
\end{figure}


\subsection{Utilizing PORT's Flexibility}
In addition to novel formats, we wanted to see if PORT could be used to
represent proven-useful models from other work.  One candidate for this
effort is the work on describing malicious behavior done by Dornhackl et
al. in 2014~\cite{Dornhackl2014}.  This work improves upon static malicious
behavior detection using signatures by creating formal models that can
detect misbehavior in an application's dynamic activity.  This is done
using two models: one that describes malicious activity in the form of a
series of tasks and a second that maps these tasks onto the concrete
Windows API calls required to carry out these tasks.

PORT is particularly well suited to implementing the second model.  This
requires a mechanism for first grouping a set of similar API calls
into a single operation and then describing a malicious task in terms of
these aggregate operations.  PORT supports the former using variants.
For example, the work proposes grouping the API calls that may be used to
open a Windows registry key as is shown in Figure~\ref{lst:DornhacklOpen}.

\begin{figure}[H]
\begin{lstlisting}
OPEN => RegOpenKeyA NtOpenKey
  | RegOpenKeyW NtOpenKey
  | RegOpenKeyExA NtOpenKey
  | RegOpenKeyExW NtOpenKey
\end{lstlisting}
\caption{Grouping of Windows API calls for opening or creating a Windows
  registry key into an OPEN operation as per Dornhackl et al.}
\label{lst:DornhacklOpen}
\end{figure}


In the above grammar, each symbol beginning with ``Reg'' represents a user
API that opens or creates a registry key.  {\tt NtOpenKey} always follows
each of these calls because it is the underlying ``native'' call that
Windows makes to actually perform the operation.
The grouping and execution semantics for this operation can be expressed
in PORT as shown in Figure~\ref{lst:PORTOpenReg}.


\begin{figure}[H]
\begin{lstlisting}[gobble=2]
  event open {RegOpenKeyA ...} | {RegOpenKeyW ...};
    # ... further varients omitted
  event NtOpenKey {...};

  open({...});
  NtOpenKey({...});
\end{lstlisting}
  \caption{Abstract PORT program (with parameters
  omitted) that groups the Windows API calls responsible for opening or
  creating a Windows registry key into an open operation.  It also shows
  how the requirement that NtOpenKey follow any of these calls can be
  captured.}
\label{lst:PORTOpenReg}
\end{figure}

Dornhackl et al. used this strategy to describe a pattern that, if
detected, would indicate
a Windows registry key was being installed
that would cause some malicious action
the next time the machine was restarted.  We can use PORT to group the
Windows API calls into the same operations as the original work and
construct a program that could perform this detection (assuming PORT were
extended to support Windows).  Such a program appears in
Figure~\ref{lst:PORTRegDetect}.  This program groups API calls into OPEN,
SET, and CLOSE operations and searches for a pattern that
indicates
an application is
setting an autostart key.  The PORT program is further able to express
that the pattern must appear for a specific registry key using the value
stored in the ``regkey'' register.

\begin{figure}[H]
\centering
\begin{tabular}{c}
\begin{lstlisting}[gobble=2]
  event open {RegOpenKeyA ...} | {RegOpenKeyW ...} | ...;
    # further variants omitted
  event NtOpenKey {...};
  event set {RegSetValueExA ...} | {RegSetValueExW ...}
            | ...;  # further variants omitted
  event NtSetValueKey {...};
  event close {RegCloseKey ...};
  event NtClose {...};

  open({...});
  NtOpenKey({...});
  set({...});
  NtSetValueKey({...});
  close({...});
  NtClose({...});
\end{lstlisting}
\end{tabular}
  \caption{This listing shows an abstract PORT program (with parameters
  omitted) that detects situations where an application is maliciously
  installing an ``autostart'' Windows registry key.  It does so by
  implementing the pattern described by Dornhackl et al.  Unimportant
  parameters are omitted and the number of API calls in each group has been
  reduced in order to save space.}
\label{lst:PORTRegDetect}
\end{figure}


\subsection{PORT's Performance}

It doesn't matter how useful a tool may be
if it takes too long to complete its work.
Though our implementation is
only a prototype, we wanted to make sure that its performance was not
overly slow.
Our performance evaluation
is focused on the time required
to identify specific
patterns within real world system call traces.
We recorded test traces
from two popular network applications -
NCat,
and
Python's http.server.
These
were chosen because they are widely used and
offer increasing levels of complexity against which we can evaluate
PORT's effectiveness.

Our test operated as follows.  The applications were configured to service
a simple piece of content (a single string in the case of NCat) and were
recorded using {\tt strace} while handling a request from a remote client.
The strace
recordings\footnote{Recordings were pre-processed to remove system calls
related to executable loading and process creation} were then processed using the PORT program from
Figure~\ref{lst:RealWorldPerformance},  which
identified the sequence of system calls that implement
a server's request handling
loop.  Table~\ref{tbl:RealWorldPerformance}
shows the times in seconds required to perform this identification on each
web server as well as the total number of system calls in each trace.

\begin{figure}
  \begin{tabular}{|c|c|c}
                & Time in Sec. & Num. Syscalls.\\
              \hline
  http.server   & 0.104 Sec.   & 297   \\
  NCat          & 0.092 Sec.   & 43      \\
\end{tabular}
\caption{Time in seconds to process the listed number of events of each format.}
\label{tbl:RealWorldPerformance}
\end{figure}

\begin{figure}[H]
\centering
\begin{tabular}{c}
\begin{lstlisting}[gobble=2]
  event accept { accept fd: Number@ret}
             | { accept4 fd: Number@ret};
  event anyrecv { recvfrom fd: Number@0}
    | { read fd: Number@0} | { recv fd: Number@0};
  event anysend {sendto fd: Number@0}
    | { write fd: Number@0} | { send fd: Number@0};
  event close {fd: Number@0};

  accept({fd: storefd});
  anyrecv({fd: ?storefd});
  anysend({fd: ?storefd});
  close({fd: ?storefd});
\end{lstlisting}
\end{tabular}
\caption{This PORT program matches patterns where a server application
  accepts a connection, receives a request, sends a response, and closes
  the connection.  The program uses variants to handle cases where
  applications use different system calls to perform some common action
  (e.g. receiving data from a socket)}
\label{lst:RealWorldPerformance}
\end{figure}

The results in Table~\ref{tbl:RealWorldPerformance} show that, as expected,
PORT's
processing time increases in line with the total number of system calls
present in a recording.  We anticipate that much of this processing cost is
associated with setting up a Python execution environment and that a more
optimized implementation could improve performance gains in this area.
Further,
it is likely that PORT's performance is closely tied to
disk throughput,
and that advancing the mutator
as each system call is evaluated
adds little additional overhead.
A condition with varying disk
speeds could be designed to confirm this suspicion.  As a whole, our
results indicate that PORT's performance is not a limiting factor to its
usage in real-world situations.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "paper"
%%% End:
