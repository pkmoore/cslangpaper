\section{Evaluation}
\label{SEC:evaluation}

With our prototype in hand we organized a set of
evaluations that would let us know if the PORT would be effective
in real world situations.
We designed our tests to answer the following questions:

\begin{itemize}

    % Re-implementing CS anomalies
  \item{Can PORT express the sorts of anomalies used by SEA to identify
    bugs?}

    % Extending to support RPC formats
  \item{How easy is it to extend PORT to support activity representations
    other than system calls?}

    % Dornhackl et al. defining maliciousness
  \item{What sorts of problems can be addressed by employing PORT on
  non-system-call activity representations?}

    % Performance information
  \item{Can PORT process input streams in a reasonable amount of time?}

\end{itemize}


\subsection{Expressing SEA Anomalies}
\label{sub:SEAAnomalies}
Given that this work was motivated
in large part
by the effectiveness of the SEA technique,
our first test of PORT was using it to reproduce the anomalies described
in the original paper.
We wanted to ensure that
the language we developed
would be sufficiently powerful
to describe the anomalies the
SEA research team used to
find bugs.
Specifically,
we set out to test PORT's ability to recreate
the study's Unusual Filetype mutator,
and its Cross-disk file move checkers, which were used to identify
the bulk of
the bugs that were found.
Our hope was that by using PORT we could eliminate boiler plate code,
save effort by handling common tasks automatically, and improve reliability
by providing a structured way to modify and output system call sequences.

\begin{figure}[H]
\centering
\begin{tabular}{c}
\begin{lstlisting}
event statbuf {mode: String@2};
event anystat {stat sb: statbuf@1}
        | {lstat sb: statbuf@1} | {fstat sb: statbuf@1};
anystat({sb: {mode: ->"st\_mode=S\_IFBLK"}});
\end{lstlisting}
\end{tabular}
\caption{This program identifies a stat, lstat, or fstat call and modifies
  the ST\_MODE member of its statbuf output parameter to contain the value
  "S\_IFBLK."  This indicates that the file being examined is a block device
  rather than a regular file.}
\label{lst:UnusualFiletypePORT}
\end{figure}

\subsubsection{Creating the Unusual Filetype Mutator}
\label{subsub:UnusualFiletype}
For the first phase of this work,
we used PORT to implement an ``Unusual Filetype''
mutator.
This mutator, presented in
Figure~\ref{lst:UnusualFiletypePORT},
should take an input trace
that contains a call to either {\tt stat()},
{\tt fstat()},
or {\tt lstat()}
and modify the call's result data structure such
that its {\tt ST\_MODE} member will contain a value
that indicates an unusual filetype.
Table~\ref{tbl:ST_MODEValues}.  As can be seen in
Figure~\ref{lst:UnusualFiletypePORT}, PORT's semantics mean such an
operation can be captured with only a handful of lines of code.  In the
figure
lines 1 through 4 define what {\tt stat()}, {\tt fstat()}, and {\tt
lstat()} calls look like and which parameter contains the result buffer.
Line 6 generates an accepting state that, when entered, produces an output
system call with a modified value in the return structure's {\tt st\_mode}
field.  Such output can then be used to modify the results of a running
application's system calls in order to carry out the remaining steps of the
SEA technique.

PORT's advantages are made even more obvious when the PORT Unusual
Filetype mutator is compared to a program that implements the same
functionality in a general purpose programming language like Python.
Figure~\ref{lst:UnusualFiletypePython} shows an excerpt from a 55 line
Python program taken from the SEA paper's CrashSimulator that performs the
same mutation described above.  Comparing this listing to
Figure~\ref{lst:UnusualFiletypePORT} shows several key differences:

\textit{Minimal boilerplate code:} The PORT program lacks the boilerplate
code associated with
reading an input trace, managing mutator state, and producing output.
This is possible because PORT's capabilities are narrowly defined to
only describe the states and operations of a mutator.  This means these
functions can be generically implemented within PORT's core eliminating
the need for users to do so manually.

\textit{No code required to filter out uninteresting calls:}
PORT's user does
not need to write any code to exclude system
calls outside of the desired set.  Each statement defines a new state with
incoming and outgoing transitions configured such that any system calls not
dealt with in the PORT program are ignored.

\textit{Easy to modify call contents:}  PORT's operators make it
trivial to change components of a system call
and produce output without having to regenerate the remainder of its
parameters.
This is a far cry
from the Python program which relies on manual, fragile string manipulation
to achieve the same effect.


\begin{figure}[H]
\centering
\begin{tabular}{c}
\begin{lstlisting}[language=python]
... 3 lines omitted ...
class UnusualFiletypeMutator(GenericMutator):
  def \_\_init\_\_(self, filetype='S\_IFREG', name=None, file\_descriptor=None):
  ... 6 lines omitted ...

  def mutate\_syscalls(self, syscalls):
    index = self.\_find\_index(syscalls)
    for i in range(len(syscalls[index].args)):
      if 'st\_mode' in str(syscalls[index].args[i].value):
        syscalls[index].args[i].value=re.sub(r'S\_IF(\w*)', self.filetype, syscalls[index].args[i].value)

... 13 lines omitted ...

  def identify\_lines(self, tm, que, thread\_condition):
    while True:
      ... 3 lines omitted ...
      if syscall\_trace['syscall'].name.startswith('fstat'):
        if self.file\_descriptor:
          if self.file\_descriptor != syscall\_trace.args[0].value:
            continue
        self.opportunity\_identified(syscall\_trace, self.mutator\_name, que)
      if syscall\_trace['syscall'].name.startswith('stat') or syscall\_trace['syscall'].name.startswith('lstat'):
        if self.name:
          if self.name != syscall\_trace.args[0].value:
            continue
        self.opportunity\_identified(syscall\_trace, self.mutator\_name, que)
\end{lstlisting}
\end{tabular}
\caption{This is a Python module taken from SEA's CrashSimulator that
  implements the ``Unusual Filetype'' anomaly.  This listing has been
  shortened by removing CrashSimulator specific-code so that a fair
  comparison can be drawn between it and the same mutator implemented in
  PORT.}
\label{lst:UnusualFiletypePython}
\end{figure}

\subsubsection{Creating the Cross-Disk Move Checkers}

The second phase of this work involved the recreation of a set of
``checkers'' that could examine an application as it moved a file from one
disk to another and report whether or not the operation was carried
out correctly.  These checkers took advantage of the fact that the Linux
{\tt rename()} system call does not support moving files from one disk to
another.  This means applications have to perform this complex
operation manually.  Earlier work on the SEA technique
identified XX steps required to
correctly perform such a move by examining the source code of the ``mv''
command.  With this knowledge, they
implemented a set of checkers to identify situations where one
or more of these steps were not carried out correctly.
When applied to real world applications,
these checkers were able to identify bugs
in many popular applications and libraries that offered file movement
capabilities.

Similar to the Unusual Filetype described in
Section~\ref{subsub:UnusualFiletype},
we first implemented the
set of checkers in PORT.  Figure~\ref{lst:Cross-DiskMovePORT} shows one
such checker that ensures {\tt fstat} is used after a file is opened but
before it is moved.  This pattern indicates that an application may be
storing the {\tt inode} number of the file -- a step necessary to prevent a race
condition where the file is replaced during the move process.  When
we compare this checker to the Python version in
Figure~\ref{lst:Cross-DiskMovePython} many of the qualities we discussed
above are apparent.  The PORT version is more concise and its meaning is
less obscured by boilerplate and state management code that makes up the
bulk of the Python version.

This exercise did expose one of PORT's shortcomings.
The Python checker in Figure~\ref{lst:XattrsPython},
which ensures an application
preserves all of a file's extended attributes and re-applies them the
destination file after the move.
The difficulty creting this checker
in PORT was due to two factors.
First, PORT does not support looping with a
runtime-defined number of iterations.  This is necessary to capture all
calls to {\tt getxattr()}.
Further, PORT does not support a list data structure to store the values
retrieved by such calls and ensure they have all been applied with a
corresponding call to {\tt setxattr()}.
We are evaluating these deficiencies and plan to address them in the
future.

\begin{figure}[H]
\centering
\begin{tabular}{c}
\begin{lstlisting}[language=c,showstringspaces=false]
\\ This is absolutely a fake listing that will be changed out for a real
\\ one!!  Preston -> Don't forget to do this!
#include "stdio.h"

int main() {
    printf("Hello world!\n");
    return 0;
}
\end{lstlisting}
\end{tabular}
\caption{One of the cross disk move checkers implemented in PORT}
\label{lst:Cross-DiskMovePORT}
\end{figure}


\begin{figure}[H]
\centering
\begin{tabular}{c}
\begin{lstlisting}[language=c,showstringspaces=false]
\\ This is absolutely a fake listing that will be changed out for a real
\\ one!!  Preston -> Don't forget to do this!
#include "stdio.h"

int main() {
    printf("Hello world!\n");
    return 0;
}
\end{lstlisting}
\end{tabular}
\caption{One of the cross disk move checkers implemented in Python}
\label{lst:Cross-DiskMovePython}
\end{figure}

\subsection{Extending PORT to Other Activity Representations}

While the above results are encouraging, we wanted to ensure that PORT's
usefulness was not limited to system call manipulation.
A logical next step would be to test PORT's capabilities when working
with a higher level, but similarly structured, activity representation.
After some consideration we settled on JSONRPC and XMLRPC.  These formats
were ideal because they are well defined, popular, and both have well
supported parsing libraries or modules.

To evaluate PORT's ability to work with these representations we
constructed transformer modules that could convert these formats into our
intermediate data format.
We tested our implementation by writing PORT programs that could modify
activity streams similar to the examples presented in the JSONRPC
2.0~\cite{jsonspec} and XMLRPC~\cite{xmlspec}
specifications.  One such program is shown in
listing~\ref{lst:JSONProgram}.  This program matches a pattern of ``test''
and ``update'' calls and, if the pattern is found, the final update call's
parameters are replaced with the contents of two registers.

JSONRPC support required handful of hours of effort and XMLRPC
support, whose implementation we precisely timed, was completed in three
hours and thirty-two minutes.  Based on the ease and speed with which we
ere able to complete these additions we are confident that PORT can be
quickly adapted to support new activity representations as required.

\begin{figure}[H]
\centering
\begin{tabular}{c}
\begin{lstlisting}
event update {up1: Number@0, up2: Number@1};
event test {tp1: Number@0, tp2: String@1};
update({up1: pone, up2: ptwo});
test({tp1: 45, tp2: "alpha"});
update({up1: ->999, up2: ->888});
\end{lstlisting}
\end{tabular}
\caption{This PORT program matches a pattern of JSONRPC calls to
  ``update'' and ``test.''  If the pattern is identified, the final call to
  update is modified so that its first two parameter values are replaced
  with the values stored in the outone and outtwo registers.}
\label{lst:JSONProgram}
\end{figure}


\subsection{Utilizing PORT's Flexibility}
In addition to novel formats, we wanted to see if PORT could be used to
represent proven-useful models from other work.  One candidate for this
effort is the work on describing malicious behavior done by Dornhackl et
al. in 2014~\cite{Dornhackl2014}.  This work improves upon static malicious
behavior detection using signatures by creating formal models that can
detect misbehavior in an application's dynamic activity.  This is done
using two models: one that describes malicious activity in the form of a
series of tasks and a second that maps these tasks onto the concrete
Windows API calls required to carry out these tasks.

PORT is particularly well suited to implementing the second model.  This
requires a mechanism for first grouping a set of similar API calls
into a single operation and then describing a malicious task in terms of
these aggregate operations.  PORT supports the former using variants.
For example, the work proposes grouping the API calls that may be used to
open a Windows registry key as is shown in Figure~\ref{lst:DornhacklOpen}.

\begin{figure}[H]
\centering
\begin{tabular}{c}
\begin{lstlisting}
OPEN => RegOpenKeyA NtOpenKey
  | RegOpenKeyW NtOpenKey
  | RegOpenKeyExA NtOpenKey
  | RegOpenKeyExW NtOpenKey
\end{lstlisting}
\end{tabular}
\caption{Grouping of Windows API calls for opening or creating a Windows
  registry key into an OPEN operation as per Dornhackl et al.}
\label{lst:DornhacklOpen}
\end{figure}


In the above grammar, each symbol beginning with ``Reg'' represents a user
API that opens or creates a registry key.  {\tt NtOpenKey} always follows
each of these calls because it is the underlying ``native'' call that
Windows makes to actually perform the operation.
The grouping and execution semantics for this operation can be expressed
in PORT as shown in Figure~\ref{lst:PORTOpenReg}.


\begin{figure}[H]
\begin{lstlisting}[gobble=2]
  event open {RegOpenKeyA ...} | {RegOpenKeyW ...};
    # ... further varients omitted
  event NtOpenKey {...};

  open({...});
  NtOpenKey({...});
\end{lstlisting}
  \caption{Abstract PORT program (with parameters
  omitted) that groups the Windows API calls responsible for opening or
  creating a Windows registry key into an open operation.  It also shows
  how the requirement that NtOpenKey follow any of these calls can be
  captured.}
\label{lst:PORTOpenReg}
\end{figure}

Dornhackl et al. used this strategy to describe a pattern that, if
detected, would indicate
a Windows registry key was being installed
that would cause some malicious action
the next time the machine was restarted.  We can use PORT to group the
Windows API calls into the same operations as the original work and
construct a program that could perform this detection (assuming PORT were
extended to support Windows).  Such a program appears in
Figure~\ref{lst:PORTRegDetect}.  This program groups API calls into OPEN,
SET, and CLOSE operations and searches for a pattern that
indicates
an application is
setting an autostart key.  The PORT program is further able to express
that the pattern must appear for a specific registry key using the value
stored in the ``regkey'' register.

\begin{figure}[H]
\centering
\begin{tabular}{c}
\begin{lstlisting}[gobble=2]
  event open {RegOpenKeyA ...} | {RegOpenKeyW ...} | ...;
    # further variants omitted
  event NtOpenKey {...};
  event set {RegSetValueExA ...} | {RegSetValueExW ...}
            | ...;  # further variants omitted
  event NtSetValueKey {...};
  event close {RegCloseKey ...};
  event NtClose {...};

  open({...});
  NtOpenKey({...});
  set({...});
  NtSetValueKey({...});
  close({...});
  NtClose({...});
\end{lstlisting}
\end{tabular}
  \caption{This listing shows an abstract PORT program (with parameters
  omitted) that detects situations where an application is maliciously
  installing an ``autostart'' Windows registry key.  It does so by
  implementing the pattern described by Dornhackl et al.  Unimportant
  parameters are omitted and the number of API calls in each group has been
  reduced in order to save space.}
\label{lst:PORTRegDetect}
\end{figure}


\subsection{PORT's Performance}

It doesn't matter how useful a tool may be
if it takes too long to complete its work.
Though our implementation is
only a prototype, we wanted to make sure that its performance was not
overly slow.
Our performance evaluation
is focused on the time required
to identify specific
patterns within real world system call traces.
We recorded test traces
from two popular network applications -
NCat,
and
Python's http.server.
These
were chosen because they are widely used and
offer increasing levels of complexity against which we can evaluate
PORT's effectiveness.

Our test operated as follows.  The applications were configured to service
a simple piece of content (a single string in the case of NCat) and were
recorded using {\tt strace} while handling a request from a remote client.
The strace
recordings\footnote{Recordings were pre-processed to remove system calls
related to executable loading and process creation} were then processed using the PORT program from
Figure~\ref{lst:RealWorldPerformance},  which
identified the sequence of system calls that implement
a server's request handling
loop.  Table~\ref{tbl:RealWorldPerformance}
shows the times in seconds required to perform this identification on each
web server as well as the total number of system calls in each trace.

\begin{figure}
  \begin{tabular}{|c|c|c}
                & Time in Sec. & Num. Syscalls.\\
              \hline
  http.server   & 0.104 Sec.   & 297   \\
  NCat          & 0.092 Sec.   & 43      \\
\end{tabular}
\caption{Time in seconds to process the listed number of events of each format.}
\label{tbl:RealWorldPerformance}
\end{figure}

\begin{figure}[H]
\centering
\begin{tabular}{c}
\begin{lstlisting}
event accept { accept fd: Number@ret} | { accept4 fd: Number@ret};
event anyrecv { recvfrom fd: Number@0} |
  { read fd: Number@0} |
  { recv fd: Number@0};

event anysend {sendto fd: Number@0}
  | { write fd: Number@0}
  | { send fd: Number@0};

event close {fd: Number@0};

accept({fd: !storefd});
anyrecv({fd: ?storefd});
anysend({fd: ?storefd});
close({fd: ?storefd});
\end{lstlisting}
\end{tabular}
\caption{This PORT program matches patterns where a server application
  accepts a connection, receives a request, sends a response, and closes
  the connection.  The program uses variants to handle cases where
  applications use different system calls to perform some common action
  (e.g. receiving data from a socket)}
\label{lst:RealWorldPerformance}
\end{figure}

The results in Table~\ref{tbl:RealWorldPerformance} show that, as expected,
PORT's
processing time increases in line with the total number of system calls
present in a recording.  We anticipate that much of this processing cost is
associated with setting up a Python execution environment and that a more
optimized implementation could improve performance gains in this area.
Further,
it is likely that PORT's performance is closely tied to
disk throughput,
and that advancing the mutator
as each system call is evaluated
adds little additional overhead.
A condition with varying disk
speeds could be designed to confirm this suspicion.  As a whole, our
results indicate that PORT's performance is not a limiting factor to its
usage in real-world situations.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "paper"
%%% End:
