\section{Language Overview}
\label{sec:Overview}

\begin{figure}
  \includegraphics[scale=.8]{images/processing}
  \caption{A Mutator individually processes each item in an input
  sequence.  For each item in the sequence, the Mutator updates it's
  internal state and produces outputs according to the rules described in
  its program.}
  \label{fig:processing}
\end{figure}

\preston{The processing figure is not mentioned anywhere}

The purpose
of a CSlang program is to completely describe a Mutator
that both
accepts a chosen stream if it contains a particular
activity sequence and can produce a modified
output stream
for application testing.
Because a Mutator is essentially an enhanced transducer,
this description must cover all states,
their associated output,
and the transition
relation that ties them all together.
Simply enumerating every aspect of a Mutator could be very verbose
so we intentionally tailored CSlang's semantics to allow its users to
describe complex configurations in a concise manner.
In Section~\ref{sub:SyntaxAndSemantics}, we discuss the
language's syntax and semantics and illustrate the details
with small examples.  Section~\ref{sub:DatawordOperators} takes a more
detailed look at important operators.

\subsection{What Does an Event Stream Look Like?}
\label{sub:EventLookLike}
Stream of events
Events have a unique identifier and associated data -> parameters



\subsection{Preamble and Body}
\label{sub:PreambleAndBody}

A CSlang program can be divided into two sections: the preamble and the body.
The purpose of the preamble is to define the sorts of events that are
expected
to appear in an input event stream and the set of components from those
events future statements will operate on.  Specifying this information up
front configures a CSlang mutator to
automatically ignore extraneous information from the incoming stream.  This
means that subsequent body statements only have to deal with events and
parameters that pertain to the goal of the program.

Body statements are responsible for configuring the states and transitions
that will be included in the mutator being described by a CSlang program.
Each statement (excluding usages of the NOT operator) configures a single
state and the rules that govern transitioning into it.
In order for a Mutator to transition into a new state
the current event must ``match'' the requirements of the destination state.
 Matching requires that three rules be satisfied:

\begin{itemize}
\item{The event's identifier must match the destination state's identifier}
\item{All parameters with the match operator applied must have a value equal to
  the value currently stored in the associated register (discussed further
    in Section~\ref{sub:DatawordOperators}}
\item{All predicates must be satisfied by the parameter values in the
  current event}
\end{itemize}




\subsection{Syntax and Semantics}
\label{sub:SyntaxAndSemantics}

Figure~\ref{lst:SyntaxGrammar} contains a simplified
version of CSlang's grammar.

\begin{figure}[H]
\centering
\begin{tabular}{c}
\begin{lstlisting}

S: statementlist
statementlist: statement*
statement: eventdefinition
           | variantdefinition
           | assignment
           | dataword
eventdefinition: id (id\_1, t\_1, l\_1), ..., (id\_n, t\_n, l\_n)
variantdefinition: var\_id ed\_1, ..., ed\_n
assignment: x <- e
dataword: id paramexp predexp outputexp
paramexp: (pid\_1, op\_1, regid\_1), ..., (pid\_n, op\_n, regid\_n)
predexp: (lhs\_1, cmp\_1, rhs\_1), ..., (lhs\_n, cmp\_n, rhs\_n)
outputexp: id paramexp
e \in Expr := e\_1 + e\_2 | e\_1 - e\_2 | ...
\end{lstlisting}
\end{tabular}
\caption{Grammer of CSlang's syntax}
\label{lst:SyntaxGrammar}
\end{figure}


\begin{quote}
\centering
\textbf{S: statementlist}
\end{quote}

This production triggers the creation of a Mutator with only a starting
state.  This state is accepting in two situations:
\begin{itemize}
  \item{When no other states are added to the automaton by subsequent
    statements}
  \item{When the only other states added to the automaton are NOT states
    which reject sequences they match}
\end{itemize}
In all other cases this is a rejecting state that produces no output.

\begin{quote}
\centering
\textbf{assignment: x <- e}
\end{quote}

Assignment statements store the value of an expression, e, into a named
register on the Mutator being described.
If the register does not exist,
it is created;
otherwise its stored value is overwritten.
Registers may contain Numeric or String values.  Register contents
may be used in subsequent statements to specify parameter values that must
be present in order for an event to match or as values to be output.

\begin{quote}
\centering
\textbf{eventdefinition: id (id\_1, t\_1, l\_1), ..., (id\_n, t\_n, l\_n) }
\end{quote}

\begin{figure}[H]
\centering
\begin{tabular}{c}
\begin{lstlisting}

type statbuf {dev: String@0, stino: String@1, mode: String@2};
type fstat {filedesc: Numeric@0, statstruct: statbuf@1};

\end{lstlisting}
\end{tabular}
\end{figure}

An event definition statement describes an event that could appear in an input
stream.  Each statement specifies an event ``variety'' and a list of
parameters that should be accessible in later dataword statements.
An event's variety corresponds
with the system call name, RPC call name, or, in the case of other activity
representations, a unique identifier that would allow events of the same
variety to be picked out of a stream.

The second line in the above example shows an event
definition for the {\tt fstat()} system call with two parameters: a numeric
file descriptor and ``statbuf'' structure named statbuf.
The first line in the above defines the layout of a statbuf.


\begin{quote}
\centering
\textbf{variantdefinition: var\_id ed\_1, ..., ed\_n}
\end{quote}

\begin{figure}[H]
\centering
\begin{tabular}{c}
\begin{lstlisting}
type bothread {read filedesc: Numeric@0} | {recv filedesc: Numeric@0};
\end{lstlisting}
\end{tabular}
\end{figure}

A variant definition allows several event definitions to be combined under
a single identifier.  This identifier may then be used in a dataword
statement to match any of the collected events.  This feature arose as a
result of situations where one of several system calls could be used to
perform the same operation (e.g. {\tt read()} and {\tt recv()}).  The
concrete syntax necessary to achieve this pairing is shown in the example
above where the variant ``bothread'' is defined such that it will match
either a {\tt read()} or {\tt recv()} system call.

\begin{quote}
\centering
\textbf{dataword: id paramexp predexp outputexp}
\end{quote}

\begin{figure}[H]
\centering
\begin{tabular}{c}
\begin{lstlisting}

fstat({statstruct: {dev: !finddev2, stino: !findino2}})
with filedesc == 4 and statstruct.dev == "st_dev=makedev(0, 4)"
-> fstat({filedesc: ->fdout2});

\end{lstlisting}
\end{tabular}
\end{figure}

Dataword statements are responsible for adding new states to the
Mutator.  This means they must specify any register operations,
transition conditions, and output associated with these new states.  To
tackle this complexity we will address each part of this production
individually.

\textit{id paramexp}

The parameter expression offers an opportunity to examine and store
parameter values from the current event.  CSlang supports two operators
that may be applied to parameter expression members.  The match operator
(!) allows for the rejection of otherwise matching events
by enforcing a required value on a
chosen parameter while the store operator (?) copies a value from the
current event and stores it in the specified register.


\textit{predexp}

Predicate expressions are used to place additional restrictions that must
be met if the Mutator is to advance into the newly created state.  These
restrictions compare values from the current event to either register
values or literal values.

\textit{outputexp}

An output clause controls the output that will be produced when its
associated state is entered.  The nature of this output is controlled by a
parameter expression that specifies which parameters of the current event
should be replaced with a value from a register.  If a parameter is not
included in the parameter expression, its original value is used.
Similarly,
if an output clause is omitted the original, unmodified event is output.

\subsection{Dataword Operators}
\label{sub:DatawordOperators}

CSlang supports two operators that may be applied to a dataword's
parameters: Match and Store.  These operators are a central component in
the description of a Mutator.

\subsubsection{Store Operator (!)}

The store operator, ``\textit{!}'', adds a requirement that the
Mutator should extract a value from the current event and store
it in the specified register.  These values may then be modified by
register expressions, combined with the match operator to add more
entry requirements to a state, or used in output expressions.

\subsubsection{Match Operator (?)}

The match operator, ``\textit{?}'', allows CSlang's user to
require that the value of the event parameter it is operating on matches
the value in the specified register.  This functionality is
useful when a value is stored upon the occurrence of one event
and then used to identify an associated event expected to appear later.
A common example of this pattern is storing the file descriptor
returned by an {\tt open()} or {\tt socket()} call into a register
and using it to find related {\tt read()} further along in a system call
trace.

\subsubsection{The NOT keyword}

The NOT keyword is used to reject a sequence if the event being
described is encountered.  This is done by creating a ``trap''
rejecting state.  Such a state follows the same entry rules
as a normal state but has no outgoing transitions.  This guarantees that a
recording containing matching events will be rejected.
We found this capability useful for writing programs that could identify
situations where an application incorrectly performs one or more steps of a
complex operation.




%%%% We need to talk about how we are different from other
%%%% languages that are regular-expression like here
%\subsection{Inspiration from Regular Expressions}
%
%
%%%% This is probably better called something more generic like "type
%%%% system" because we also have variant types and need to describe why we
%%%% included them and how they help us express stuff
