\section{Architecture}
\label{SEC:architecture}

\begin{figure}
  \includegraphics[scale=.08]{images/architecture}
  \caption{The CSLang compiler produces a transducer that operates over a
  generic intermediate representation of the contents of a given trace.}
  \label{fig:architecture}
\end{figure}


%!!! This paragraph is about how we wanted to improve encoding and will
%!!! probably disappear
%%% We want to capture and encode anomalies
%%The SEA technique's power comes from its ability to capture and encode
%%anomalies so they can be repeatedly employed to test applications.  But, as
%%previous work discussed, taking advantage of this feature can be
%%% What are the challenges -> writing the programs
%%challenging.  Based on these qualities, we reasoned the capture process
%%% Improvement efforts here feel out of place.  We are not improving SEA, we
%%% are working on a new language
%%was a good candidate for our improvement efforts.
%%As a first step, we examined the encoded anomalies used in the
%%earlier SEA work and found several deficiencies.
%%They were
%%long (in terms of lines of code),
%%difficult to read and maintain,
%%and tightly coupled to the implementation details of system calls.
%%We decided to address each of these concerns by developing a new
%%programming language, CSLang.  Our goal with CSLang was to provide a way to
%%describe anomalies that was concise, easy to understand, and generic enough
%%that it could support many message formats.
\subsection{The CSlang Compiler}

% !!! This part is about the transducer which is now covered in language
% !!! overview
%%% We used a transducer as a model
%While the development of CSLang
%is the star of the show,
%it is important to first understand
%several new components
%that form the language's foundation.
%At the core of our efforts is
%a new model for recognizing and transforming streams of messages.  Our
%model is based on a finite-state transducer and builds upon the earlier SEA
%work's success at describing simulation opportunities using deterministic
%finite automata.  We chose the transducer as our foundation
%because it better suits our need for stream editing and allows us to get
%rid of the secondary mutation step described in earlier work.
%Instead, recognition and transformation of streams can be done at the same time.

\subsection{Supporting Many Activity Representations}

In order to take the SEA technique beyond system calls we wanted to make
CSlang flexible enough that it could work with many different sorts of
activity representations.
To achieve this objective we needed to cleanly separate the details of how
an application's activity was recorded from the representation that will be
processed by a CSlang transducer.
Our solution was twofold.  First, we developed an internal data format
(IDF) that
could store the key components, such as parameter and return values,
of application activities like function
calls and system calls.  This format supports primitive string and numeric
values as well as arbitrarily nested structures in the form of records.
These decisions were based on the Linux kernel's system call implementation
which allows system call inputs and outputs in the form of primitive data
values and complex C structures.
If CSlang were going to support system calls, these capabilities would be
necessary and, further, we found that the same capabilities allowed us to
support other activity representations.

The second component is the set of modules, known as transformers, that can
convert an activity stream from its original representation into IDF and
back.  A transformer achieves the former by parsing each activity entry,
extracting the relevant fields, and assembling this information into an IDF
record.  These records are re-assembled into a stream which is input into a
CSlang transducer.  The result of processing this stream undergoes the
reverse.  The output IDF stream is converted by a transformer back into the
original activity representation.  The current version of CSlang ships with
three transformers:
\begin{itemize}
\item{strace via Posix-Omni-Parser}
\item{JSONRPC via Python's json module}
\item{XMLRPC via Python's lxml module}
\end{itemize}


% !!! This paragraph is about the generic internal representation
% !!! and will probably need to stay
%%%% We convert the stream of messages to a generic format
%The model does not serve much purpose without a stream of messages to
%operate on.
%This stream is provided by our second component,
%the message format adaptor,
%which takes
%stream of messages in their original representation and converts
%them into a format that a CSLang transducer can consume. This conversion process
%captures the identifying information and parameters of each message in the
%input stream and stores them in CSLang's Intermediate Data Format (IDF).
%Operating on this generic intermediate format means CSLang transducers are
%not dependent on a specific message format.

\subsection{Executing a CSlang Program}
%%% We have this thing that hands the stream of stuff off to the
%%% automaton
%A final component, known as the CSLang executor,
%receives both the transducer and the converted message stream.
%This program is responsible for passing each message of the stream
%to the transducer
%so that it may advance its internal state and
%produce the appropriate output.
%In this case, output comes in the form of modifications to the IDF stream itself.
%If the transducer
%ends in an accepting state, the stream of messages has
%been modified to include an anomaly and will be output in its original
%representation.  If the automaton is not in an accepting state, the stream
%did not contain an opportunity to simulate the described anomaly.
%
%<Something Something Something how simulation works goes here?>

%\begin{itemize}
%  \item{Language describing anomalies}
%  \item{Formal model of transducer that can implement anomalies}
%  \item{Tool to compile description into said formal transducer}
%  \item{Format-agnostic intermediate data structure (IDS) over which transducer
%  operates}
%  \item{Translation layer for converting to and from concrete data into IDS}
%\end{itemize}

