\section{Introduction}
\label{SEC:introduction}

% Talk here about streaming data
Whether it be stock prices, sensor data, or application logs,
streams are everywhere.
And a great deal of value can be gleaned
from examining the contents of streaming data
in order to identify and act upon
interesting patterns.
Earlier work in the areas of stream
processing~\cite{asdf}
and Complex Event Processing~\cite{asdf} bear this
out.
% Need to explain why stream processing and Complex Event Processing
% are high level.
% Follow the above sentence with an example that is not SEA
This work aims to take these successes
and apply similar strategies
at a much lower level,
the internal activity of individual applications,
in order to improve application reliability by catching bugs.

% At this point, I have not built the case strongly enough for what we are
% doing.
To this end,
we've constructed
a new domain specific language called CSlang.
CSlang allows its user to describe sequences of operations an application
might carry out and
then use these descriptions
to monitor an application's system calls,
remote procedure calls,
or other actions in order to determine if it has
performed what was described.
This is possible because a CSlang program is
compiled into a transducer that,
like a more standard transducer,
consumes an input stream
and produces appropriate output
according to its transition relation.
In the case of CSlang,
the transducer in question is able to
both recognize the activity it is looking for as it arises
and produce output according to the rules laid down in the CSlang
program from which it was built.

% May need to move this above the previous paragraph
Our inspiration for this work came from other efforts in developing
the SEA technique~\cite{ASDF}.
This technique showed that bugs could be found by looking at situations
where other
applications had failed, figuring out why they failed, and then imposing
the conditions, known as an ``anomaly'',
that caused a failure on another application to see how it
responds.

% This paragraph might need to be rolled into the above "to this end..."
% paragraph
It was reported that most of the effort involved when using the technique
was expended in encoding the anomalies once
they had been identified.
To improve the situation we decided to build a language
that could more clearly
encode anomalies across the set of applications that use
structured communications like remote procedure calls.
Such a tool would allow
anomalies that were
valuable in testing one application to be directly used to test other
applications with similar communication strategies.

% We need a paragraph somewhere in here that describes what information we
% got out of the SEA technique and why it motivated us to undertake this
% work

% Maybe we need to have the motivating example up here in the introduction
% instead of as a subsection in the background


To see if we achieved our initial goal, we re-implemented the
anomalies previously described in the initial SEA paper~\cite{crashsim}.
Our recreations were dramatically more concise (up to XXX\% in some cases)
than their counterparts.  Side-by-side comparison shows that our new
descriptions are
more maintainable,
and simpler to update as needed.
This lowers SEA's barrier to entry allowing the
technique to be more easily used by a wider audience.
%%% say that we chose JSON/XMLRPC in order to demonstrate that the
%%% technique works on complex, application layer protocols rather than
%%% just super low level stuff like system calls

% I don't like the performance/speed comparison here.  Focus on usability
%%% SOMEWHERE we need to talk about how old mutators were tightly coupled
%%% to system calls and now we can write a mutator and run on whatever
%%% we ingest

Encouraged by this initial success,
we applied CSlang to another domain.
We used the language to describe a set of XXX anomalies that can occur in
applications that use JSONRPC or XMLRPC and employed them against
suitable
applications that ranked highly on Debian's popularity contest.  This
exercise identified AAA new bugs in the tested applications.
What's more, these descriptions can be reused on
similar applications to expose more
bugs without additional test writing effort.

The main contributions in this work can be summarized as follows:

\begin{itemize}

\item{We present a new language, {\em CSLang},
  which allows for concise, but powerful, descriptions of
    application activity and what should be output when they arise.}

%\item{We present an expanded version of the Simulating Environmental
%  Anomalies (SEA) technique that can expose bugs both between an
%    application and its environment and between application components that
%    communicate with one another}

\item{We demonstrate our success at finding bugs by employing CSlang
  alongside the SEA technique}

\item{We illustrate the flexibility of CSLang by using it to recognize
  sequences in several types of application activity.}

\item{We prove the usability of CSLang by illustrating the ease with which
  anomalies can be constructed.}


\end{itemize}

