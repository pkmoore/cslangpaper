\section{\uppercase{Introduction}}
\label{sec:introduction}

%H. Dornhackl, K. Kadletz, R. Luh and P. Tavolato,
% "Defining Malicious Behavior,"
%2014 Ninth International Conference on Availability,
%Reliability and Security, Fribourg, Switzerland, 2014,
%pp. 273-278, doi: 10.1109/ARES.2014.43.
% Using a formal model to encode some sort of desired behavior

{\textit ``Actions speak louder than words...'' - Unknown}


It is a well established principle
that, in the wake of an application failure,
its actions
during execution can provide clues
to the root cause.
Such information
can not only help correct
the cause of failure,
but also prevent its repetition through the creation
of better test methods.
The challenge is 
how to identify and extract this data
from large and detailed sources like application logs,
system call traces,
or application recordings.
In other words, how does one
accurately describe what activity is important
and what you should do when you find it?
% This paper covers our efforts to make this process easier.

In considering this question,  we drew inspiration from two sources. The
first is a recent study that confirmed the value of monitoring and
modifying an applicationâ€™s  interactions with its environment~\cite{DBLP:conf/issre/MooreCFW19}.  Using a technique known as SEA (Simulating Environmental Anomalies), the study demonstrated that when an application fails, the causal properties
will be visible in the results of the system calls it made. Further, the study affirmed these results could
be captured and simulated for testing against other applications.  The
second source was the significant amount of literature supporting the use of event
processing techniques over large streams of data~\cite{DBLP:conf/sigmod/AgrawalDGI08,DBLP:conf/debs/Hirzel12,DBLP:journals/ibmrd/HirzelAGJKKMNSSW13,DBLP:journals/csur/DayarathnaP18}. We posited that techniques
currently used to identify problems in  manufacturing environments, or patterns in
network outages, could also be used to accurately recognize target
sequences in large
application activity streams.

Building upon these successes,
we introduce a tool
that utilizes event processing techniques
to identify
behaviors 
that may cause applications to fail.
What makes this possible is PORT
(\textbf{P}attern \textbf{O}bservation, \textbf{R}ecognition, and
\textbf{T}ransformation),
a new domain specific language
that can describe these behaviors
in a briefer and more easily understood manner than conventional languages. In turn, the descriptions can be used
to search recordings of an application's actions
across a variety of ``activity representations.'' That is, it can search
system calls,
or remote procedure calls and determine if  an application either executed a desired behavior
or avoided an undesired one.
Further, PORT can specify
a set of modifications
to be made
if a particular activity sequence is encountered.
By combining passive monitoring and active activity modification,
PORT can aid in identifying bugs
in a wide variety of programs
that might be missed by other testing strategies.

We determined that harnessing PORT's passive and active capabilities could best be done
by compiling a PORT program
into a mutator.
Operating  on principles similar
to a standard finite-state transducer,
the mutator will consume an input sequence of activity
to determine if a particular pattern is present. At the same time, it
produces an output stream.
If the mutator accepts the input sequence of a stream,
it means the described activity is present.
In some cases,
this may directly indicate
the existence of a bug. In
others, 
the pattern may
be employed
for more detailed testing in which an application's response to the 
modified output sequence indicates a flaw.
Unlike a standard transducer, however,  
a PORT mutator works using a generic representation we call our ``Intermediate Data Format (IDF).''
An IDF can both abstract the details of a concrete event to make writing PORT programs easier, and 
act as a medium through which modifications can be made to events even without any details of their contents.

We first evaluate the effectiveness of the above technique by
creating a prototype implementation of PORT
and using it to
re-implement the ``anomalies''
described in the earlier work on the SEA technique~\cite{DBLP:conf/issre/MooreCFW19}.
Side-by-side comparison shows that our new
descriptions are more concise,
readable,
and maintainable
than their original counterparts.
As an added benefit,
PORT can expand the use of the SEA technique,
which has already been proven
to be an effective bug detector,
by facilitating its use
on a wider variety of applications and activity formats.

Next, we
determined how well PORT
supports activity streams
other than system calls.
To do so, we 
added support for two remote procedure call formats --
JSONRPC~\cite{jsonspec} and XMLRPC~\cite{xmlspec}.
This effort
showed that PORT is both quick and easy to extend largely because of its
use of a generic intermediate data format.

We also demonstrate that PORT can be used for applications other than software testing.
Specifically, we sketch how a model used for
detecting malicious behavior in Windows applications due to Dornhackl et al.~\cite{Dornhackl2014} can be implemented in PORT.

Finally, we show that PORT programs are able to quickly process recordings taken from real world applications.  Our results show that thousands of executions can be completed in a handful of seconds.
%This plan details how PORT could be used to
%implement each of the components required by their technique.


The main contributions in this work can be summarized as follows:

\begin{itemize}

\item We create a new domain specific language, {\em PORT},
  that allows for concise descriptions of patterns
  that may be
  found and transformed in an application's activity stream.

\item We show how PORT can utilize the SEA technique on a wider scale by finding bugs using more types of activity streams.

\item We provide an open source implementation of PORT available for immediate use
at: \textit{Link removed for blinding purposes. Additionally, we will submit an artifact for evaluation if accepted.}

\end{itemize}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "paper"
%%% End:
