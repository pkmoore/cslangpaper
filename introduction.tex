\section{Introduction}
\label{SEC:introduction}

%H. Dornhackl, K. Kadletz, R. Luh and P. Tavolato,
% "Defining Malicious Behavior," 
%2014 Ninth International Conference on Availability, 
%Reliability and Security, Fribourg, Switzerland, 2014, 
%pp. 273-278, doi: 10.1109/ARES.2014.43.
% Using a formal model to encode some sort of desired behavior

{\textit ``Actions speak louder than words...'' - Unknown}

It is a well established principle
that, in the wake of a failure,
monitoring and examining the actions
of an application
during execution can give insight
into its root cause.
Taking advantage of such information
can aid in correcting
the cause of failure
and assist in the creation
of tests to ensure that it
is not repeated in the future.
The challenge is in
how to identify and extract this data
from large and detailed sources like application logs,
system call traces,
or application recordings.
Central to this problem
is accurately describing what activity is important
and what to do when you find it.
This work covers our effort to make the process easier.

In addressing this difficulty,
we draw inspiration from two sources.
First is the great amount of literature supporting the use of event
processing techniques over large streams of data such as
industrial control system sensor readings,
transaction processing software,
and networking monitoring systems.
We argue that the techniques used
to achieve success
in these domains
can be applied
to large application activity streams to accurately
and efficiently recognize target behavior.
The second is a recent successful effort
to identify bugs by monitoring
and modifying an application's interactions with its environment.

We combine and build upon these successes
by introducing a tool
that adapts event processing techniques
in order to allow its users to
test which aspects of an environment
could interfere with
the successful operation of an application.
What makes this possible is CSlang,
a new domain specific language
that allows users
to describe sequences of operations
an application might carry out.
These descriptions are then used
to monitor an application's system calls,
remote procedure calls,
or other actions in order to determine if it has
performed what was described.
CSlang also permits
its user to describe a set of modifications
to be made to an activity sequence should it be encountered.
By combining passive monitoring and active modification
of an application's activity,
CSlang aids in identifying environmental bugs
that may be missed by other testing strategies.

This combined approach is possible
because a CSlang program
is compiled into a transducer
that operates on similar principles
to a standard finite-state transducer.
That is,
it consumes an input sequence of activity
to determine if the desired pattern is present
and simultaneously produces an output stream by
following the rules laid down in its CSlang program.
The results of this are twofold.
If the transducer accepts the input sequence
it means the described activity is present which,
depending on the nature of the sequence
may indicate the existence of a bug.
In cases where acceptance indicates an opportunity
for more detailed testing,
the modified output sequence may be used
to drive a simulation (as with the earlier work on environmental bugs) or populate
a test suite in order to evaluate an application's response
to the situation represented by the modifications.

We evaluated our prototype CSlang implementation initially by 
re-treading proven ground.
This involved re-implementing the ``anomalies''  
described in earlier work on the SEA technique~\cite{crashsim}.
Our recreations were dramatically more concise (up to XXX\% in some cases)
than their counterparts.  Side-by-side comparison shows that our new
descriptions are
more maintainable,
and simpler to update as needed.
This lowers SEA's barrier to entry allowing the
technique to be more easily used by a wider audience.

Next, we wanted to take CSlang beyond manipulating system calls.
To do so, 
we exploited the ease with which
CSlang can be augmented
to consume new input formats
by adding support for JSONRPC and XMLRPC.
These formats were chosen
because they are popular,
well supported communication formats
used by major applications.
Using this new support
we wrote programs
that could identify opportunities
to modify the results of RPC calls.
The output from these programs was used to populate a test suite
for each application.
When executed, these test suites identified AAA new bugs in the tested applications.

The main contributions in this work can be summarized as follows:

\begin{itemize}

\item{We present a new language, {\em CSLang},
  which allows for concise, but expressive, descriptions of
    application activity and the action to take should they arise}

\item{We demonstrate our success at finding bugs by employing CSlang
  alongside the SEA technique}

\item{We illustrate the flexibility of CSLang by extending it to test applications
that use a variety of communication protocols. }

\end{itemize}

