\section{Background and Motivation}
\label{SEC:background}


\subsection{Our Motivating Example}
\label{sec:MotivatingExample}
% How SEA showed success using system calls

The initial impetus for this work came from a review
of earlier efforts by Moore et al.
that lead to the creation of
the Simulating Environmental Anomalies (SEA) technique.
This effort centered on the key insight
that problematic
environmental properties,
known as anomalies, are visible in the
communications between the components that make up an application.
The researchers found that,
once captured,
these anomalies
could be
used to create simulations
that test
an application as if
it had encountered that anomaly
in the real world.
In that work, SEA was used to test applications
by recording the system calls they made
during execution,
modifying the results of these calls such that a desired anomaly
was present,
and then observing the application to see whether or not it
responded correctly to the anomaly.
Using this strategy, the authors were able to identify numerous bugs
in major applications~\cite{DBLP:conf/issre/MooreCFW19}.

As a concrete example of the above
consider the ``Unusual Filetypes'' anomaly
discussed in the SEA paper's evaluation.
This anomaly may be problematic
when an application running under Linux
attempts to open and read data from a file on disk.
In addition to ``regular'' files,
which are used to store text and
binary data,
Linux supports several special file types.
Each of these file types requires special procedures when writing to and
reading from them.
As a result, an application should check the type of files it intends to
process so that it can handle it correctly.
SEA tests program's responses
to unexpected file types
by recording and analyzing a trace of system calls,
identifying file reads and writes,
and checking whether they are preceded by a {\tt stat}
system call (or another call from the same family).
Absence of a {\tt stat} calls
immediately indicates
that the application is vulnerable
to failure
when exposed to an unexpected file type.
Even if a {\tt stat} call is present,
the application may not respond correctly.
In this situation,
SEA simulates
the behavior
of the application
when exposed
to an unusual file type
by modifying the return value
of the {\tt stat} call,
thereby simulating the anomalous environment.
Moore et al. accomplish this manually
by writing a script
for each anomaly
to process system call traces.
CSlang allows us to describe
the pattern of interest
and modifications
to the system call recording
more easily.

Our takeaway
from reading this study
was that an application's activity
is a valuable resource that can be systematically mined
in order to find bugs
that may be missed by other techniques.
The work described in this paper
is based on our own key insight that the best way to extract this
valuable data
is to treat application activity
as a sequence of events
so that proven event processing techniques
may be employed to analyze them.
Two realizations followed shortly after this
insight.
First was that, with the correct tools,
SEA's success in identifying environmental bugs using system calls
could be expanded
to encompass other activity types
like calls to library functions
and remote procedure calls.
And, the second was the understanding that existing
stream processing tools
are not well suited to the
task we had in mind.


%%% What are we really doing here.  WHY did we decided to make this language?
%%% That's really the question that needs to be answered.  I think that instead
%%% of making things up that we had the language and decided to apply it here
%%% we need to talk about how seeing the success of this work motivated us to
%%% try it at a larger scale.  We can avoid talk of "Augmenting" SEA or
%%% whatever though

\subsection{Explaining Environmental Bugs}

Before we discuss the details of our bug-finding efforts it is necessary to
draw a boundary around the types of bugs we are targeting.
This work sets its sights on the bugs that occur when some external
entity supplies unexpected or incorrect data to an
application resulting in its failure.
Such bugs may appear in simple situations like a library function that
returns data in an unexpected format or in scenarios as complex
as a request to a remote
system returning bad data because of corruption on an intermediate network
node.
Both cases share the commonality that the symptoms of misbehavior
can be found in a recording of the application's activity.
These bugs, defined by Moore et al. as ``environmental bugs,''
often cause applications to fail after deployment
and occur with such frequency
that the ``works on my machine'' phenomenon is a well known
source of pain
and frequent topic of discussion
in software and project management
literature~\cite{notreal}.
The problem is so widespread
that FAKESTUDY concluded
that \$XXX are spent annually on efforts to
recall,
fix,
and re-deploy applications
because of all the bugs
that slipped past extensive testing efforts
during development.

The impact of these bugs continues to be reinforced by the regular
appearance of dangerous environmental bugs in major pieces of
software~\cite{devzeroroot}.  And it appears that no class of application
is safe with environmental bugs affecting operating systems~\cite{bad},
user applications~\cite{bad} and even web applications~\cite{bad} in the
last year alone!


\subsection{Why a New Programming Language?}
\begin{figure}
  \begin{lstlisting}
    type open {filename: String@0,
                   filedesc: Numeric@ret};

    type read {filedesc: Numeric@0};

    type close {filedesc: Numeric@0,
                    retval: Numeric@ret};

    # Register initialization.
    # Registers do not have to be initialized
    # before use
    retval <- "-1";

    # Match an open call, store the file name
    # and returned file descriptors
    # to the 'filename' and 'filedesc'
    # registers respectively
    open({filename: !fn, filedesc: !fd});

    NOT read({filedesc: ?fd});

    # Match a close call its the value
    # in 'filedesc' as the file descriptor
    # being closed
    close({retval: ->retval, filedesc: ?fd});

  \end{lstlisting}
  \caption{A listing of a CSlang program.  This program finds situations
  where a program opens a file and closes it without reading from it.  In
  such instances, it modifies the return value close call to be -1,
  indicating failure.}
  \label{fig:CSlangListing}
\end{figure}

\begin{figure}
  \begin{lstlisting}
pattern = Pattern(
  SeqOperator(
     PrimitiveEventStructure("OPEN", "a"),
     NegationOperator(
        PrimitiveEventStructure("READ","b")
     ),
     PrimitiveEventStructure("CLOSE","c")),
AndCondition(EqCondition(
     Variable("a", lambda x: x["File Handle"]),
     Variable("c", lambda x: x["File Handle"])),
     EqCondition(
     Variable("c", lambda x: x["File Handle"]),
     Variable("b", lambda x: x["File Handle"]))),
timedelta(minutes=10))
  \end{lstlisting}
  \caption{
    A listing of an OpenCEP pattern to match an event stream consisting of an OPEN event followed, later in the event stream, by a CLOSE event such that a no intervening READ event occurs on the FILE HANDLE specified in the corresponding OPEN and CLOSE events.
}
  \label{fig:OpenCEPListing}
\end{figure}


The decision to create a new programming language was not one we
undertook lightly,
as such an effort takes
a significant amount of work
to define,
implement, document, and support.
In this section we discuss the features we needed for this work
and why existing systems fell short.

Our primary requirement was a language that could identify specific
patterns as they appear in a recording of application activity.
At first glance, it seems this could be met by a simple model,
such as a deterministic finite automaton (DFA).
The description could be written
in a language similar to
regular expressions, but enhanced to operate on complex
structures rather than symbols in a string.
However, many patterns contain a dependency
between activities
across time.
The program in Figure~\ref{fig:CSlangListing} demonstrates this.
The {\tt open()} call produces a file descriptor that a subsequent {\tt
read()} call may match.
Matching patterns with this sort of dependency is beyond the capability
of a standard DFA.
Instead we need a language
that can describe
a model that allows
the internal contents of events,
like argument data,
pointer addresses,
and return values
to be easily captured, manipulated, and
reused in subsequent operations.

One possibility is to describe a register automaton,
though this model also has disqualifying limitations.
Chief among these is that it does not allow for modified output to be
produced during processing.
Our review of the work on the SEA technique has shown that the ability to
{\textit modify} activity is central to forcing
an application into situations where
it may fail rather than only passively monitoring to see if it performs
problematic sequences.
This level of complexity is similar to what is offered by
the feature-rich nature of several event processing
languages and libraries.
Unfortunately, we found that, while it was possible to modify and output
incoming events with several of these languages,
it is by no means a straightforward
and ergonomic experience.
In fact, in many cases producing an output stream that met
our needs would require
falling back on the fully-featured nature of a host language -- a situation
we hoped to avoid.

In the initial stages of CSlang's development we
evaluated several event processing tools to see
they could meet our needs.
Specifically,
we focused on
complex event processing (CEP) languages because they
could
provide some of the pattern and predicate matching primitives
that we wished to
incorporate.
Unfortunately,
none of those we examined fit our purposes
because they either could not support the features
we required or because their complexity would
interfere with our goal of producing a system
that was easy to understand and use.
Typically,
programs for these complex event processing engines are
written in the engine's build or host language,
such as Java,
Scala or
Python.
This choice tends to necessitate a great deal of boilerplate code,
which other work exploring how developers read and
understand (or mis-understand!) code has shown
can obscure a programs meaning, harming understanding and
maintainability~\ref{CITEATOMSWORK}.
Further,
it means that the author,
and future maintainers,
of a
program must be fluent in this host language.
Finally,
these languages include features and optimizations
that are would likely not be useful to the CSLang feature set.
These include time-based event windows,
merging multiple event streams,
and the calculation of
summary statistics over specified fields in the event stream.

As a concrete demonstration of the differences between a CEP
program we have included the code from two small programs, written in
CSlang and OpenCEP, a CEP module for the Python programming language.
Figure~\ref{CSlangListing}
which shows a CSLang program that matches sequences wherein an
application opens and closes a file without reading from it. When such a
sequence is identified by the matching engine, the return code of the
"close" event is changed to -1, indicating failure.
The main work of this
program is performed in just four lines of CSLang code.  Figure 2 contains
an OpenCEP\cite{open_cep_website} pattern that implements an approximation
of the same program as seen in Figure~\ref{fig:CSlangListing}.
This program is only
an approximation because the OpenCEP pattern does not modify the return
value of the "close" call and forces the user to specify a time window
within which the pattern matching will take place.

% A domain specific language like CSLang provides a more
% concise syntax that makes it easier for all individuals to read and
% write relevant programs in.
% In light of this, we believe the benefits of a
% new programming language
% focused on letting its users get a lot of work done
% with a small amount of easily-readable code should be self-evident.

% The second front involves CSlang's programming paradigm.
% While other event processing languages tend toward functional or
% declarative programming,
% CSlang programs more closely follow an imperative programming style.
% We came to this decision because studies
% have shown that developers are more likely to be familiar and comfortable
% with such a paradigm~\cite{XXXX}.  We believe this will make it easier for
% developers to learn the language, foster greater popularity, and it aligns
% with the goals presented in our motivating example.



