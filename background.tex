\section{Background and Motivation}
\label{SEC:background}


\subsection{Our Motivating Example}
\label{sec:MotivatingExample}
% How SEA showed success using system calls

The initial impetus for this work came from a review
of earlier efforts by Moore et al.~\cite{DBLP:conf/issre/MooreCFW19}
that lead to the creation of
the Simulating Environmental Anomalies (SEA) technique.
This effort centered on the key insight
that problematic
environmental properties,
known as anomalies, are visible in the
communications between the components that make up an application.
The researchers found that,
once captured,
these anomalies
could be
used to create simulations
that test
an application as if
it had encountered that anomaly
in the real world.
In that work, SEA was used to test applications
by recording the system calls they made
during execution,
modifying the results of these calls such that a desired anomaly
was present,
and then observing the application to see whether or not it
responded correctly to the anomaly.
Using this strategy, the authors were able to identify a number of bugs
in major applications.

As a concrete example of the above
consider the ``Unusual File types'' anomaly
discussed in the SEA paper's evaluation.
This anomaly may be problematic
when an application running under Linux
attempts to open and read data from a file on disk.
In addition to ``regular'' files,
which are used to store text and
binary data,
Linux supports several special file types.
Each of these file types requires special procedures when writing to and
reading from them.
As a result, an application should check the type of files it intends to
process so that it can handle it correctly.
SEA tests program's responses
to unexpected file types
by recording and analyzing a trace of system calls,
identifying file reads and writes,
and checking whether they are preceded by a {\tt stat}
system call (or another call from the same family).
Absence of a {\tt stat} call
immediately indicates
that the application is vulnerable
to failure
when exposed to an unexpected file type.
Even if a {\tt stat} call is present,
the application may not respond correctly.
In this situation,
SEA would
modify
the return value
of the {\tt stat} call,
thereby simulating the anomalous environment.
Moore et al. accomplish this manually
by writing a script
for each anomaly
to process system call traces.
PORT makes it easier to describe
the pattern of interest
and the  modifications required
to the system call recording.

Our takeaway
from reading this study
was that an application's activity
is a valuable resource that can be systematically mined
in order to find bugs
that may be missed by other techniques.
The work described in this paper
is based on our own key insight that the best way to extract this data
is to treat application activity
as a sequence of events,
thus allowing us to use
proven event processing techniques
to analyze them.
Two realizations followed shortly after this
insight.
First was that, a novel tool was needed to leverage
SEA's success beyond strace and system calls. Such a tool would be able to encompass other activity types,
such as calls to library functions
and remote procedure calls.
This could be achieved by operating in a fashion agnostic to the way an application's activity has been recorded.
And, the second insight was the understanding that existing
stream processing tools
are not well suited to the
task we had in mind.


%%% What are we really doing here.  WHY did we decided to make this language?
%%% That's really the question that needs to be answered.  I think that instead
%%% of making things up that we had the language and decided to apply it here
%%% we need to talk about how seeing the success of this work motivated us to
%%% try it at a larger scale.  We can avoid talk of "Augmenting" SEA or
%%% whatever though

%\subsection{Explaining Environmental Bugs}
%
%Before we discuss the details of our bug-finding efforts it is necessary to
%draw a boundary around the types of bugs we are targeting.
%This work sets its sights on the bugs that occur when some external
%entity supplies unexpected or incorrect data to an
%application resulting in its failure.
%Such bugs may appear in simple situations like a library function that
%returns data in an unexpected format or in scenarios as complex
%as a request to a remote
%system returning bad data because of corruption on an intermediate network
%node.
%Both cases share the commonality that the symptoms of misbehavior
%can be found in a recording of the application's activity.
%These bugs, defined by Moore et al. as ``environmental bugs,''
%often cause applications to fail after deployment
%and occur with such frequency
%that the ``works on my machine'' phenomenon is a well known
%source of pain
%and frequent topic of discussion
%in software and project management
%literature~\cite{worksonmymachine}.
%Post-deployment bugs are a widespread problem
%and they come with significant costs
%both in financial terms and,
%in the worst cases,
%loss of life~\cite{WONG201768}.
%
%The impact of these bugs continues to be reinforced by the regular
%appearance of dangerous environmental bugs in major pieces of
%software~\cite{devzeroroot}.  And it appears that no class of application
%is safe with environmental bugs affecting operating
%systems~\cite{ubuntuappaport},
%user applications~\cite{westerndigitalsymlink} and crucial security
%programs~\cite{sudocopy} in the
%last year alone!
%
%\begin{figure}
%  \begin{lstlisting}[gobble=4]
%    # Before Modification
%    open("example.txt", O_RDWR, 0) = 3
%    fstat(3, {...}) = 0
%    getpid() = 34355
%    write(3, "Hello World!\n", 13) = 13
%    close(3) = 0
%
%    # After Modification
%    open("example.txt", O_RDWR, 0) = 3
%    fstat(3, {...}) = 0
%    getpid() = 34355
%    write(3, "Hello World!\n", 13) = 13
%    close(3) = -1
%  \end{lstlisting}
%  \caption{A system call trace of a program that opens, writes to, and closes
%  a file before and after modifying the return value of the \texttt{close()} call.}
%  \label{fig:StraceListing}
%\end{figure}

\subsection{Why a New Domain Specific Language?}
\begin{figure}
  \begin{lstlisting}[gobble=4,xleftmargin=.8em]
    event open {filedesc: Number@ret};
    event read {filedesc: Number@0};
    event close {filedesc: Number@0, retval: Number@ret};
    open({filedesc: fd});
    not read({filedesc: ?fd});
    close({filedesc: ?fd});
  \end{lstlisting}
  \caption{A listing of a PORT program.  This program finds situations
  where a program opens a file and closes it without reading from it.}
  \label{fig:PORTListing}
\end{figure}



\begin{figure}
  \begin{lstlisting}
pattern = Pattern(
  SeqOperator(
     PrimitiveEventStructure("OPEN", "a"),
     NegationOperator(
        PrimitiveEventStructure("READ","b")
     ),
     PrimitiveEventStructure("CLOSE","c")),
AndCondition(EqCondition(
     Variable("a", lambda x: x["File Handle"]),
     Variable("c", lambda x: x["File Handle"])),
     EqCondition(
     Variable("c", lambda x: x["File Handle"]),
     Variable("b", lambda x: x["File Handle"]))),
timedelta(minutes=10))
  \end{lstlisting}
  \caption{
    A listing of an OpenCEP pattern to match an event stream consisting of
    an {\tt open} event followed later in the event stream by a {\tt close}
    event such
    that a no intervening {\tt read} event occurs
    on the file descriptor specified in the corresponding {\tt open}
    and {\tt close} events.
}
  \label{fig:OpenCEPListing}
\end{figure}


The decision to create a new domain specific language was not one we
undertook lightly,
as such an effort takes
a significant amount of work
to define,
implement, document, and support.
In this section we discuss the features we needed for this work
and why existing systems are not well suited for this domain.

Our primary requirement was a language that could identify specific
patterns as they appear in a recording of application activity.
At first glance, it seems this could be met by a simple model,
such as a deterministic finite automaton (i.e. a DFA or a FSA).
The description could be written
in a language similar to
regular expressions, but enhanced to operate on complex
structures rather than symbols in a string.
Unfortunately, we found such a model does not meet our needs, primarily because patterns contain dependencies
between activities
across time,
as shown in Figure~\ref{fig:StraceListing}.
The {\tt open()} call produces a file descriptor that a subsequent {\tt
read()} call may match.
Yet, it is beyond the capability
of a standard DFA or FSA to match patterns with this sort of dependency. 
Instead we need a language
that can easily capture
the internal contents of events,
like argument data,
pointer addresses,
and return values that can be
manipulated for
reuse in subsequent operations.

One possibility is to deploy more expressive automata models, such as register automata~\cite{DBLP:journals/tcs/KaminskiF94} or session automata~\cite{DBLP:journals/corr/BolligHLM14}. Yet, these models are still too limited as
they do not permit  the production of a modified output. 
We learned from the  SEA researchers that the ability to
{\textit modify} activity allows researchers to create scenarios  that ensure
application failures rather than  waiting for it to possibly  perform
problematic sequences.
Several feature-rich event processing
languages and libraries do have these capabilities, but
modifying and outputing
incoming events
is by no means a straightforward experience.
In many cases, producing an output stream that met
our needs would require
falling back on the fully-featured nature of a host language (e.g. Java) -- a situation
we hoped to avoid.

In the initial stages of PORT's development, we also
evaluated several event processing tools,
including
complex event processing (CEP) languages that
could
provide some of the pattern and predicate matching primitives
that we wished to
incorporate.
Unfortunately,
these languages did not
support  the features
we require,
or were too complex
for the easy to use  system we were looking to offer.
Typically,
programs for these complex event processing engines are
written in the engine's build or host language,
such as Java,
Scala or
Python.
Such languages generally bring with them a great deal of boilerplate code,
that can obscure or confuse
the program's meaning.
Recent studies
have affirmed that excessive and complicated code
patterns can harm
understanding and
maintainability~\cite{misunderstandings}.
Further,
it means that the author,
and future maintainers,
of a
program must be fluent in this host language.
Finally,
these languages include features and optimizations
that would likely not be useful for our application domain.
These include time-based event windows,
merging multiple event streams,
and the calculation of
summary statistics over specified fields in the event stream.


To demonstrate these points concretely,
we consider two programs that recognize a system call sequence wherein an
application opens and closes a file
without reading from it.
Figure~\ref{fig:PORTListing} shows a PORT program that implements this
task.  The first three statements in this program define the events (i.e.
system calls) and parameters relevant to the task it performs.  The final three statements express that the event stream
should contain an \texttt{open()} call followed by a \texttt{close()} call on the same file descriptor, with no intermittent \texttt{read()} call.

We compare this program 
\footnote{which can be executed using the code and tools available at: \textit{Link Removed for Blinding Purposes}}
with a corresponding program written in OpenCEP~\cite{open_cep_website},
a CEP module for the Python programming language.
This program is shown in Figure~\ref{fig:OpenCEPListing}.
The PORT program is both more concise with its main work being done in just
three lines of code, and more readable because it is not constrained by the
requirements of a host programming language.
PORT further differentiates itself from OpenCEP and similar languages by
offering the ability to modify and output an event.
That is, the program in Figure~\ref{fig:PORTListing} could be
re-purposed to not only find the appropriate pattern but also modify the
results of the {\tt close} call to simulate a failure.
This would be achieved
by editing line 8 of the program to contain an output
clause as follows:
\begin{lstlisting}[numbers=none,xleftmargin=0em,gobble=2,columns=strict]
  close({filedesc: ?fd}) -> close({retval: -1});
\end{lstlisting}
If the modified PORT program is executed on the system call trace shown in the upper half of Fig.~\ref{fig:StraceListing}, it will produce the modified system call trace shown in the bottom half.

% A domain specific language like PORT provides a more
% concise syntax that makes it easier for all individuals to read and
% write relevant programs in.
% In light of this, we believe the benefits of a
% new programming language
% focused on letting its users get a lot of work done
% with a small amount of easily-readable code should be self-evident.

% The second front involves PORT's programming paradigm.
% While other event processing languages tend toward functional or
% declarative programming,
% PORT programs more closely follow an imperative programming style.
% We came to this decision because studies
% have shown that developers are more likely to be familiar and comfortable
% with such a paradigm~\cite{XXXX}.  We believe this will make it easier for
% developers to learn the language, foster greater popularity, and it aligns
% with the goals presented in our motivating example.




%%% Local Variables:
%%% mode: latex
%%% TeX-master: "paper"
%%% End:
