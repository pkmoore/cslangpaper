\section{Background and Motivation}
\label{SEC:background}


\subsection{Our Motivating Example}
\label{sec:MotivatingExample}
% How SEA showed success using system calls

The initial impetus for this work came from a review
of earlier efforts by Moore et al.
that lead to the creation of
the Simulating Environmental Anomalies (SEA) technique.
This effort centered on the key insight
that problematic
environmental properties,
known as anomalies, are visible in the
communications between the components that make up an application.
The researchers found that,
once captured,
these anomalies
could be
used to create simulations
that test
an application as if
it had encountered the captured anomalies
in the real world.
In that work, SEA was used to test applications
by recording the system calls they made
during execution,
modifying the results of these calls such that a desired anomaly
was present,
and observing the application to see whether or not it
responded correctly to the anomaly.
Using this strategy, the authors were able to identify numerous bugs
in major applications~\cite{DBLP:conf/issre/MooreCFW19}.

As a concrete example of the above
consider the ``Unusual Filetypes'' anomaly
discussed in the SEA paper's evaluation.
This anomaly appears
when an application running under Linux
attempts to open and read data from a file on disk.
In addition to ``regular'' files,
which are used to store text and
binary data,
Linux supports several special file types.
Each of these file types requires special procedures when writing to and
reading from them.
As a result, an application should check the type of files it intends to
process so that it can handle it correctly.
To use this anomaly, the authors intercepted applications' attempts to
examine files with system calls from the {\tt stat} family and modified
their results to make regular files appear as if they were one of the
unusual file types.
Applications that failed to recognize the presence of
an unusual file often handled it incorrectly leading to hangs,
crashes, and even damage to the host system as a result of disks being
completely filled.

Our takeaway
was that an application's activity
is a valuable resource that can be systematically mined
in order to find bugs
that may be missed by other techniques.
The work described in this paper
is based on our own key insight that the best way to extract this
value
is to treat application activity
as a sequence of events
so that proven event processing techniques
may be employed in analyzing them.
Two realizations followed shortly after this
insight.
First was that, with the correct tools,
SEA's success in identifying environmental bugs using system calls
could be expanded
to encompass other activity types
like calls to library functions
and remote procedure calls.
Second was the understanding that existing
stream processing tools
are not up to the
task we had in mind.


%%% What are we really doing here.  WHY did we decided to make this language?
%%% That's really the question that needs to be answered.  I think that instead
%%% of making things up that we had the language and decided to apply it here
%%% we need to talk about how seeing the success of this work motivated us to
%%% try it at a larger scale.  We can avoid talk of "Augmenting" SEA or
%%% whatever though

\subsection{Explaining Environmental Bugs}

Before we discuss the details of our bug-finding efforts it is necessary to
draw a boundary around the types of bugs we are targeting.
This work sets its sights on the bugs that occur when an some external
entity supplies unexpected or incorrect data to an
application resulting in its failure.
Such bugs may appear in simple situations like a library function that
returns data in an unexpected format or in scenarios as complex
as a request to a remote
system returning bad data because of corruption on an intermediate network
node.
Both cases share the commonality that the symptoms of misbehavior
can be found in a recording of the applications activity.
These bugs, defined by Moore et al. as ``environmental bugs,''
often cause applications to fail after deployment
and occur with such frequency
that the ``works on my machine'' phenomenon is a well known
source of pain
and frequent topic of discussion
in software and project management
literature~\cite{notreal}.
The problem is so widespread
that FAKESTUDY concluded
that \$XXX are spent annually on efforts to
recall,
fix,
and re-deploy applications
because of all the bugs
that slipped past extensive testing efforts
during development.

The impact of these bugs continues to be reinforced by the regular
appearance of dangerous environmental bugs in major pieces of
software~\cite{devzeroroot}.  And it appears that no class of application
is safe with environmental bugs affecting operating systems~\cite{bad},
user applications~\cite{bad} and even web applications~\cite{bad} in the
last year alone!


\preston{Maybe I should include something here similar to the list from the
CrashSim paper that talks about different environmental bug sources in more
detail?}



\subsection{Why a New Programming Language?}
\begin{figure}
  \begin{lstlisting}
    type open {filename: String@0,
                   filedesc: Numeric@ret};

    type read {filedesc: Numeric@0};

    type close {filedesc: Numeric@0,
                    retval: Numeric@ret};

    # Register initialization.
    # Registers do not have to be initialized
    # before use
    retval <- "-1";

    # Match an open call, store the file name
    # and returned file descriptors
    # to the 'filename' and 'filedesc'
    # registers respectively
    open({filename: !fn, filedesc: !fd});

    NOT read({filedesc: ?fd});

    # Match a close call its the value
    # in 'filedesc' as the file descriptor
    # being closed
    close({retval: ->retval, filedesc: ?fd});

  \end{lstlisting}
  \caption{A listing of a CSlang program.  This program finds situations
  where a program opens a file and closes it without reading from it.  In
  such instances, it modifies the return value close call to be -1,
  indicating failure.}
  \label{fig:cslanglisting}
\end{figure}

\begin{figure}
  \begin{lstlisting}
pattern = Pattern(
  SeqOperator(
     PrimitiveEventStructure("OPEN", "a"),
     NegationOperator(
     PrimitiveEventStructure("READ","b")),
     PrimitiveEventStructure("CLOSE","c")),
AndCondition(EqCondition(
     Variable("a", lambda x: x["File Handle"]),
     Variable("c", lambda x: x["File Handle"])),
     EqCondition(
     Variable("c", lambda x: x["File Handle"]),
     Variable("b", lambda x: x["File Handle"]))),
timedelta(minutes=10))
  \end{lstlisting}
  \caption{A listing of an OpenCEP program that does the same thing as the
  cslang program... I need to figure out what comparison stuff to put in
  this caption.}
  \label{fig:flinklisting}
\end{figure}


The decision to create a new programming language was not one we
undertook lightly,
as such an effort takes
a significant amount of work
to define,
implement, document, and support.
In this section we discuss the features we needed for this work
and why existing systems fell short.

First, we needed a language that treated state as a first-class citizen.
That is, it must allow the internal contents of events like argument data,
pointer addresses, and return values to be easily captured, manipulated, and
reused in subsequent operations.
This is necessary because,
at a very high level,
the purpose of system calls,
function calls,
rpc calls,
or other similar activity
is to allow an application
to gather data from an external module like a library or the operating
system.
As a result, it is frequently useful to be able to store the data returned by
one such action, modify it, and use it in matching actions.
For example, one may store the file descriptor returned by a {\tt
socket()} system call and use it later to match other related
communication system calls.
We found that this sort of usage was common across many types of
application activity further reinforcing our desire for a language that was
closely tailored to our needs on this in this area.

% Need to support new event stream formats easily?


\preston{We need to make sure we have given a best effort at shortening and
optimizing code from other languages with which we are making comparisons}

Our second requirement appears to be largely aesthetic at first glance
but there is a
larger purpose -- ease of learning and ease of use.  CSlang offers
improvements over existing languages along two primary fronts.
When designing CSLang we looked at several event processing languages, more
specifically complex event processing (cep) languages.  These languages
provide some of the predicate matching primitives that we wished to
incorporate into CSLang and also attempt to pattern match against a stream
of events. However, these languages also include features and optimizations
that are not envisioned as useful to the CSLang feature set - these include
time-based windows, merging multiple event streams, and the calculation of
summary statistics over specified fields in the event stream.

Rules written for these complex event processing engines are typically
written in the engine's build or host language such as Java, Scala or
Python. This necessarily means that te author of complex event processing
rules must be fluent in this host language.  In addition, it likely means
that the rules themselves may only be understood by someone fluent in the
host language.  A domain specific language like CSLang provides a more
concise syntax that we believe makes it easier for individuals to read and
write relevant programs in.

Figure 1 which shows a CSLang program that matches sequences wherein an
application opens and closes a file without reading from it. When such a
sequence is identified by the matching engine, the return code of the
"close" event is changed to -1, indicating failure. The main work of this
program is performed in just four lines of CSLang code.  Figure 2 contains
an OpenCEP\cite{open_cep_website} program that implements an approximation
of the same program that was implemented in Figure 1. This program is only
an approximation because the OpenCEP program does not modify the return
value of the "close" call and forces the user to specify a time window
within which the pattern matching will take place.h

Other work that explores how developers read and
understand (or mis-understand!) code has shown that such constructs obscure
a programs meaning, harming understanding and
maintainability~\ref{CITEATOMSWORK}.
In light of this, we believe the benefits of a
new programming language
focused on allowing its users to get a lot of work done
with a small amount of easily-readable code are evident.

% The second front involves CSlang's programming paradigm.
% While other event processing languages tend toward functional or
% declarative programming,
% CSlang programs more closely follow an imperative programming style.
% We came to this decision because studies
% have shown that developers are more likely to be familiar and comfortable
% with such a paradigm~\cite{XXXX}.  We believe this will make it easier for
% developers to learn the language, foster greater popularity, and it aligns
% with the goals presented in our motivating example.

Our final requirement is, perhaps, the most important.
We want CSlang programs to be capable of more than simply matching
a pattern of events and indicating that it has occurred.
Our review of the work on the SEA technique has shown that the ability to
{\textit modify} is central to forcing an application into situations where
it may fail rather than only passively monitoring for it to perform
problematic sequences.  While the feature-rich nature of several related
languages and libraries means it is likely possible to modify and output
incoming events, it is by no means a straightforward
and ergonomic experience.
Constructing CSlang to support output as a primary feature allows us to
easily describe the types of transformations needed to expose bugs.


