\section{Background and Motivation}
\label{SEC:background}


\subsection{Our Motivating Example}
\label{sec:MotivatingExample}
% How SEA showed success using system calls

The initial impetus for this work came from a review
of earlier efforts by Moore et al.~\cite{DBLP:conf/issre/MooreCFW19}
that lead to the creation of
the Simulating Environmental Anomalies (SEA) technique.
This effort centered on the key insight
that problematic
environmental properties,
known as anomalies, are visible in the
communications between the components that make up an application.
The researchers found that,
once captured,
these anomalies
could be
used to create simulations
that test
an application as if
it had encountered that anomaly
in the real world.
In that work, SEA was used to test applications
by recording the system calls they made
during execution,
modifying the results of these calls such that a desired anomaly
was present,
and then observing the application to see whether or not it
responded correctly to the anomaly.
Using this strategy, the authors were able to identify a number of bugs
in major applications.

As a concrete example of the above
consider the ``Unusual File types'' anomaly
discussed in the SEA paper's evaluation.
This anomaly may be problematic
when an application running under Linux
attempts to open and read data from a file on disk.
In addition to ``regular'' files,
which are used to store text and
binary data,
Linux supports several special file types.
Each of these file types requires special procedures when writing to and
reading from them.
As a result, an application should check the type of files it intends to
process so that it can handle it correctly.
SEA tests program's responses
to unexpected file types
by recording and analyzing a trace of system calls,
identifying file reads and writes,
and checking whether they are preceded by a {\tt stat}
system call (or another call from the same family).
Absence of a {\tt stat} calls
immediately indicates
that the application is vulnerable
to failure
when exposed to an unexpected file type.
Even if a {\tt stat} call is present,
the application may not respond correctly.
In this situation,
SEA simulates
the behavior
of the application
when exposed
to an unusual file type
by modifying the return value
of the {\tt stat} call,
thereby simulating the anomalous environment.
Moore et al. accomplish this manually
by writing a script
for each anomaly
to process system call traces.
PORT allows us to describe
the pattern of interest
and modifications
to the system call recording
more easily.

Our takeaway
from reading this study
was that an application's activity
is a valuable resource that can be systematically mined
in order to find bugs
that may be missed by other techniques.
The work described in this paper
is based on our own key insight that the best way to extract this
valuable data
is to treat application activity
as a sequence of events
so that proven event processing techniques
may be employed to analyze them.
Two realizations followed shortly after this
insight.
First was that, with the correct tools,
SEA's success in identifying environmental bugs using system calls
could be expanded
to encompass other activity types
like calls to library functions
and remote procedure calls.
And, the second was the understanding that existing
stream processing tools
are not well suited to the
task we had in mind.


%%% What are we really doing here.  WHY did we decided to make this language?
%%% That's really the question that needs to be answered.  I think that instead
%%% of making things up that we had the language and decided to apply it here
%%% we need to talk about how seeing the success of this work motivated us to
%%% try it at a larger scale.  We can avoid talk of "Augmenting" SEA or
%%% whatever though

\subsection{Explaining Environmental Bugs}

Before we discuss the details of our bug-finding efforts it is necessary to
draw a boundary around the types of bugs we are targeting.
This work sets its sights on the bugs that occur when some external
entity supplies unexpected or incorrect data to an
application resulting in its failure.
Such bugs may appear in simple situations like a library function that
returns data in an unexpected format or in scenarios as complex
as a request to a remote
system returning bad data because of corruption on an intermediate network
node.
Both cases share the commonality that the symptoms of misbehavior
can be found in a recording of the application's activity.
These bugs, defined by Moore et al. as ``environmental bugs,''
often cause applications to fail after deployment
and occur with such frequency
that the ``works on my machine'' phenomenon is a well known
source of pain
and frequent topic of discussion
in software and project management
literature~\cite{worksonmymachine}.
Post-deployment bugs are a widespread problem
and they come with significant costs
both in financial terms and,
in the worst cases,
loss of life~\cite{WONG201768}.

The impact of these bugs continues to be reinforced by the regular
appearance of dangerous environmental bugs in major pieces of
software~\cite{devzeroroot}.  And it appears that no class of application
is safe with environmental bugs affecting operating
systems~\cite{ubuntuappaport},
user applications~\cite{westerndigitalsymlink} and crucial security
programs~\cite{sudocopy} in the
last year alone!


\subsection{Why a New Domain Specific Language?}
\begin{figure}
  \begin{lstlisting}
    event open {filename: String@0,
                   filedesc: Number@ret};
    event read {filedesc: Number@0};
    event close {filedesc: Number@0,
                    retval: Number@ret};
    open({filename: !fn, filedesc: !fd});
    NOT read({filedesc: ?fd});
    close({filedesc: ?fd});
  \end{lstlisting}
  \caption{A listing of a PORT program.  This program finds situations
  where a program opens a file and closes it without reading from it.}
  \label{fig:PORTListing}
\end{figure}

\begin{figure}
  \begin{lstlisting}
    35388 open("example.txt", O_RDWR, 0) = 3
    35388 fstat(3, {...}) = 0
    35388 getpid() = 34355
    35388 write(3, "Hello World!\n", 13) = 13
    35388 close(3) = 0
  \end{lstlisting}
  \caption{A strace listing of a program that opens, writes to, and closes
  a file.}
  \label{fig:StraceListing}
\end{figure}

\begin{figure}
  \begin{lstlisting}
pattern = Pattern(
  SeqOperator(
     PrimitiveEventStructure("OPEN", "a"),
     NegationOperator(
        PrimitiveEventStructure("READ","b")
     ),
     PrimitiveEventStructure("CLOSE","c")),
AndCondition(EqCondition(
     Variable("a", lambda x: x["File Handle"]),
     Variable("c", lambda x: x["File Handle"])),
     EqCondition(
     Variable("c", lambda x: x["File Handle"]),
     Variable("b", lambda x: x["File Handle"]))),
timedelta(minutes=10))
  \end{lstlisting}
  \caption{
    A listing of an OpenCEP pattern to match an event stream consisting of an OPEN event followed, later in the event stream, by a CLOSE event such that a no intervening READ event occurs on the FILE HANDLE specified in the corresponding OPEN and CLOSE events.
}
  \label{fig:OpenCEPListing}
\end{figure}


The decision to create a new domain specific language was not one we
undertook lightly,
as such an effort takes
a significant amount of work
to define,
implement, document, and support.
In this section we discuss the features we needed for this work
and why existing systems are not well suited for this domain.

Our primary requirement was a language that could identify specific
patterns as they appear in a recording of application activity.
At first glance, it seems this could be met by a simple model,
such as a deterministic finite automaton (DFA).
The description could be written
in a language similar to
regular expressions, but enhanced to operate on complex
structures rather than symbols in a string.
However, many patterns contain a dependency
between activities
across time,
as shown in
in Figure~\ref{fig:PORTListing}.
The {\tt open()} call produces a file descriptor that a subsequent {\tt
read()} call may match.
Matching patterns with this sort of dependency is beyond the capability
of a standard DFA.
Instead we need a language
that can easily capture
the internal contents of events,
like argument data,
pointer addresses,
and return values
and be able to
manipulate them for
reuse in subsequent operations.

One possibility is to deploy more expressive automata models such as register automata~\cite{DBLP:journals/tcs/KaminskiF94} or session automata~\cite{DBLP:journals/corr/BolligHLM14}. Though, these models are still too limited.
In particular, they do not allow for modified output to be
produced during processing of events.
Our review of the work on the SEA technique has shown that the ability to
{\textit modify} activity is central to forcing
an application into situations where
it can fail rather than only passively monitoring to see if it performs
problematic sequences.
These capabilities are offered by several feature-rich event processing
languages and libraries.
Unfortunately, we found that, while it was possible to modify and output
incoming events with several of these languages,
it is by no means a straightforward
and ergonomic experience.
In many cases, producing an output stream that met
our needs would require
falling back on the fully-featured nature of a host language (e.g. Java) -- a situation
we hoped to avoid.

In the initial stages of PORT's development, we also
evaluated several event processing tools to see if
they could meet our needs.
Specifically,
we focused on
complex event processing (CEP) languages because they
could
provide some of the pattern and predicate matching primitives
that we wished to
incorporate.
Unfortunately,
none of those we examined fit our purposes,
either because it could not support the features
we required, or because they where too complex
to meet our
goal of producing a system
that would be easy to understand and use.
Typically,
programs for these complex event processing engines are
written in the engine's build or host language,
such as Java,
Scala or
Python,
which generally brings with it a great deal of boilerplate code,
that can obscure or confuse
the program's meaning.
Recent studies
have affirmed that excessive and complicated code
patterns can harm
understanding and
maintainability~\cite{misunderstandings}.
Further,
it means that the author,
and future maintainers,
of a
program must be fluent in this host language.
Finally,
these languages include features and optimizations
that would likely not be useful for our application domain.
These include time-based event windows,
merging multiple event streams,
and the calculation of
summary statistics over specified fields in the event stream.

To demonstrate these points concretely, we consider the example task of recognizing a system call sequence wherein an
application opens and closes a file
without reading from it, and then modifying the return value of the matched close system call to -1, indicating failure.
We compare the PORT program implementing this task (Figure~\ref{fig:PORTListing})
with a corresponding program written in OpenCEP~\cite{open_cep_website},
a CEP module for the Python programming language.
The PORT program encompasses just three lines of actual code
(excluding the definitions of the relevant event patterns,
which can be shared across all such tasks).
Figure~\ref{fig:OpenCEPListing} shows the same program written in
OpenCEP.
PORT further differentiates itself from OpenCEP and similar languages by
offering the ability to modify and output an event.
For example,
the program in Figure~\ref{fig:PORTListing} could be
re-purposed to not only identify the appropriate pattern but also modify the
results of the {\tt close} call to simulate a failure.
This would be achieved
by editing line 8 of the program to contain an output
clause as follows: {\tt close({filedesc: ?fd}) -> close({retval: -1});

% A domain specific language like PORT provides a more
% concise syntax that makes it easier for all individuals to read and
% write relevant programs in.
% In light of this, we believe the benefits of a
% new programming language
% focused on letting its users get a lot of work done
% with a small amount of easily-readable code should be self-evident.

% The second front involves PORT's programming paradigm.
% While other event processing languages tend toward functional or
% declarative programming,
% PORT programs more closely follow an imperative programming style.
% We came to this decision because studies
% have shown that developers are more likely to be familiar and comfortable
% with such a paradigm~\cite{XXXX}.  We believe this will make it easier for
% developers to learn the language, foster greater popularity, and it aligns
% with the goals presented in our motivating example.




%%% Local Variables:
%%% mode: latex
%%% TeX-master: "paper"
%%% End:
