\section{Implementation (sometimes rolled into eval)}
\label{SEC:implementation}

Implementing CSLang was a careful balancing act between providing enough
expressiveness to succinctly describe anomalies without oppressing the user
with excess complexity.  As a result, considerable thought went into the
language's feature set.  In this section we discuss notable features we
included along with our rationale for doing so.

\subsection{Inspiration from Regular Expressions}


\subsection{Record Data Types}

some messages support parameters with complex data types.  As a
result.........

\subsection{Intermediate Data Format and Message Adapter Classes}

Ensuring CSLang was easy to extend is a central concern.  We provide an
intermediate data format as well as a description of how to construct
message format adaptors cthat transform messages into it.........

\subsection{Register Operations}

Many interesting anomalies require modifications to data that occurred
earlier in the trace...  Need expressions that can do these manipulations
and output them.....


\subsection{Nuts and Bolts}
CSLang's tooling consists of AAA lines of Python code.
\begin{itemize}
\item{Parser written using PLY}
\item{Compilation results in a pure-python object serialized to disk}
\end{itemize}

\subsection{Using CSLang}

Using CSLang is a familiar process to anyone who has written, compiled, and
executed code from another programming language....

\begin{enumerate}
\item{Anomaly is identified}
\item{Anomaly is described using CSLang}
\item{Anomaly is compiled into a transducer}
\item{Transducer is executed on a stream of incoming syscalls, rpc calls, etc}
\item{Mutated calls come out the other end}
\item{Application being tested is exposed to simulation of mutated calls}
\begin{itemize}
\item{This is CrashSimulator for system calls}
\item{Some other tool for RPC applications}
\end{itemize}
\item{Results come out the other side}
\end{enumerate}
