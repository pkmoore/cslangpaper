\section{Conclusion}
\label{sec:Conclusion}
%[Be sure to end strong!  Tell the reader why your work is important.
%Explain the few key takeaways.  Benefits, eval results, usage, what is new.]
%
%[If code / data is available, reiterate]
%
%[optionally, explain future work]

A great deal of value can be gained from the analysis of an application's
activity.
Unfortunately,
the volume of activity an application produces makes it difficult
to separate out
unimportant sequences.
In this work we demonstrate our effort to improve this sitaution through the use
of our new domain specific language - CSlang.
CSlang offers a way to write concise, but powerful,
descriptions of significant application activity sequences
that can be compiled into programs that both recognize the described sequence
within an application activity stream and modify its contents in order to
facilitate more active testing.

We have also shown how easily CSlang can be extended to support other activity
representations and several scenarios where

%As we have discussed, it is common for an application to fail upon deployment
%because of unexpected interactions with its environment. Although finding and
%eliminating faults in an application is a key concern for software developers,
%it is impractical to test it in every environment it will face. To address this
%problem, we developed Simulating Environmental Anomalies (SEA). SEA is
%beneficial for developers because it allows the effort spent debugging failures
%in a given envi- ronment to be preserved and reused programmatically to test
%whether future applications will also fail. As this process is repeated, a
%corpus of bug-causing aspects, known as “anoma- lies,” along with mutators and
%checkers that characterize these anomalies, can be accumulated. In doing so,
%developers have an ever-increasing capability to test applications in situations
%that proved problematic in the past.
%
%We built a concrete implementation of SEA called Crash- Simulator that
%implements the technique by simulating en- vironmental anomalies extracted from
%the system calls an application makes. Operating on system calls gives the tool
%a “universal” way to encode and inject anomalies. Consequently, a set of
%mutations can be collected from existing applications for use in testing others.
%Our evaluation of CrashSimulator has shown that this technique is effective at
%finding bugs in well tested software. In total, 65 new bugs were identified in
%popular applications. These bugs, if triggered in the wild, could lead to
%effects ranging from simple program hangs to security vulnerabilities and data
%loss.
%
%Given that the technique has proven effective, future work to expand its use is
%warranted. This work includes developing a public repository of anomalies that
%can be applied to new or existing applications. We are also exploring
%opportunities to further automate the discovery process and improve the way
%anomalies are specified using a domain specific language. As this research
%evolves, we will focus on analyzing how an application attempts to recover from
%the anomalies. This would allow us to determine whether an application is
%correctly recovering from an error, or carrying out some incorrect response.
